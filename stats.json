[32mts-loader: Using typescript@2.1.4 and C:\workspace\nodejs\FForm\tsconfig.json[39m
{
  "errors": [],
  "warnings": [],
  "version": "2.2.0-rc.3",
  "hash": "038a04d7691713f5189b",
  "time": 4660,
  "publicPath": "",
  "assetsByChunkName": {
    "app": "FForm.min.js"
  },
  "assets": [
    {
      "name": "FForm.min.js",
      "size": 36855,
      "chunks": [
        0
      ],
      "chunkNames": [
        "app"
      ],
      "emitted": true
    }
  ],
  "entrypoints": {
    "app": {
      "chunks": [
        0
      ],
      "assets": [
        "FForm.min.js"
      ]
    }
  },
  "chunks": [
    {
      "id": 0,
      "rendered": true,
      "initial": true,
      "entry": true,
      "extraAsync": false,
      "size": 92779,
      "names": [
        "app"
      ],
      "files": [
        "FForm.min.js"
      ],
      "hash": "389bc646c4eb37c559d4",
      "parents": [],
      "modules": [
        {
          "id": 0,
          "identifier": "external \"react\"",
          "name": "external \"react\"",
          "index": 1,
          "index2": 0,
          "size": 42,
          "cacheable": false,
          "built": false,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "issuerId": 7,
          "issuerName": "./src/core.tsx",
          "profile": {
            "factory": 0,
            "building": 0
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 7,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
              "module": "./src/core.tsx",
              "moduleName": "./src/core.tsx",
              "type": "cjs require",
              "userRequest": "react",
              "loc": "30:12-28"
            },
            {
              "moduleId": 7,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
              "module": "./src/core.tsx",
              "moduleName": "./src/core.tsx",
              "type": "cjs require",
              "userRequest": "react",
              "loc": "31:14-30"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 1
        },
        {
          "id": 1,
          "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "name": "./~/is-my-json-valid/index.js",
          "index": 2,
          "index2": 6,
          "size": 16936,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "issuerId": 7,
          "issuerName": "./src/core.tsx",
          "profile": {
            "factory": 10,
            "building": 40
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 7,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
              "module": "./src/core.tsx",
              "moduleName": "./src/core.tsx",
              "type": "cjs require",
              "userRequest": "is-my-json-valid",
              "loc": "42:16-43"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 1,
          "source": "var genobj = require('generate-object-property')\nvar genfun = require('generate-function')\nvar jsonpointer = require('jsonpointer')\nvar xtend = require('xtend')\nvar formats = require('./formats')\n\nvar get = function(obj, additionalSchemas, ptr) {\n\n  var visit = function(sub) {\n    if (sub && sub.id === ptr) return sub\n    if (typeof sub !== 'object' || !sub) return null\n    return Object.keys(sub).reduce(function(res, k) {\n      return res || visit(sub[k])\n    }, null)\n  }\n\n  var res = visit(obj)\n  if (res) return res\n\n  ptr = ptr.replace(/^#/, '')\n  ptr = ptr.replace(/\\/$/, '')\n\n  try {\n    return jsonpointer.get(obj, decodeURI(ptr))\n  } catch (err) {\n    var end = ptr.indexOf('#')\n    var other\n    // external reference\n    if (end !== 0) {\n      // fragment doesn't exist.\n      if (end === -1) {\n        other = additionalSchemas[ptr]\n      } else {\n        var ext = ptr.slice(0, end)\n        other = additionalSchemas[ext]\n        var fragment = ptr.slice(end).replace(/^#/, '')\n        try {\n          return jsonpointer.get(other, fragment)\n        } catch (err) {}\n      }\n    } else {\n      other = additionalSchemas[ptr]\n    }\n    return other || null\n  }\n}\n\nvar formatName = function(field) {\n  field = JSON.stringify(field)\n  var pattern = /\\[([^\\[\\]\"]+)\\]/\n  while (pattern.test(field)) field = field.replace(pattern, '.\"+$1+\"')\n  return field\n}\n\nvar types = {}\n\ntypes.any = function() {\n  return 'true'\n}\n\ntypes.null = function(name) {\n  return name+' === null'\n}\n\ntypes.boolean = function(name) {\n  return 'typeof '+name+' === \"boolean\"'\n}\n\ntypes.array = function(name) {\n  return 'Array.isArray('+name+')'\n}\n\ntypes.object = function(name) {\n  return 'typeof '+name+' === \"object\" && '+name+' && !Array.isArray('+name+')'\n}\n\ntypes.number = function(name) {\n  return 'typeof '+name+' === \"number\"'\n}\n\ntypes.integer = function(name) {\n  return 'typeof '+name+' === \"number\" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'\n}\n\ntypes.string = function(name) {\n  return 'typeof '+name+' === \"string\"'\n}\n\nvar unique = function(array) {\n  var list = []\n  for (var i = 0; i < array.length; i++) {\n    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])\n  }\n  for (var i = 1; i < list.length; i++) {\n    if (list.indexOf(list[i]) !== i) return false\n  }\n  return true\n}\n\nvar isMultipleOf = function(name, multipleOf) {\n  var res;\n  var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1\n  if (factor > 1) {\n    var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1\n    if (factorName > factor) res = true\n    else res = Math.round(factor * name) % (factor * multipleOf)\n  }\n  else res = name % multipleOf;\n  return !res;\n}\n\nvar toType = function(node) {\n  return node.type\n}\n\nvar compile = function(schema, cache, root, reporter, opts) {\n  var fmts = opts ? xtend(formats, opts.formats) : formats\n  var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf}\n  var verbose = opts ? !!opts.verbose : false;\n  var greedy = opts && opts.greedy !== undefined ?\n    opts.greedy : false;\n\n  var syms = {}\n  var gensym = function(name) {\n    return name+(syms[name] = (syms[name] || 0)+1)\n  }\n\n  var reversePatterns = {}\n  var patterns = function(p) {\n    if (reversePatterns[p]) return reversePatterns[p]\n    var n = gensym('pattern')\n    scope[n] = new RegExp(p)\n    reversePatterns[p] = n\n    return n\n  }\n\n  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']\n  var genloop = function() {\n    var v = vars.shift()\n    vars.push(v+v[0])\n    return v\n  }\n\n  var visit = function(name, node, reporter, filter) {\n    var properties = node.properties\n    var type = node.type\n    var tuple = false\n\n    if (Array.isArray(node.items)) { // tuple type\n      properties = {}\n      node.items.forEach(function(item, i) {\n        properties[i] = item\n      })\n      type = 'array'\n      tuple = true\n    }\n\n    var indent = 0\n    var error = function(msg, prop, value) {\n      validate('errors++')\n      if (reporter === true) {\n        validate('if (validate.errors === null) validate.errors = []')\n        if (verbose) {\n          validate('validate.errors.push({field:%s,message:%s,value:%s,type:%s})', formatName(prop || name), JSON.stringify(msg), value || name, JSON.stringify(type))\n        } else {\n          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))\n        }\n      }\n    }\n\n    if (node.required === true) {\n      indent++\n      validate('if (%s === undefined) {', name)\n      error('is required')\n      validate('} else {')\n    } else {\n      indent++\n      validate('if (%s !== undefined) {', name)\n    }\n\n    var valid = [].concat(type)\n      .map(function(t) {\n        return types[t || 'any'](name)\n      })\n      .join(' || ') || 'true'\n\n    if (valid !== 'true') {\n      indent++\n      validate('if (!(%s)) {', valid)\n      error('is the wrong type')\n      validate('} else {')\n    }\n\n    if (tuple) {\n      if (node.additionalItems === false) {\n        validate('if (%s.length > %d) {', name, node.items.length)\n        error('has additional items')\n        validate('}')\n      } else if (node.additionalItems) {\n        var i = genloop()\n        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)\n        visit(name+'['+i+']', node.additionalItems, reporter, filter)\n        validate('}')\n      }\n    }\n\n    if (node.format && fmts[node.format]) {\n      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))\n      var n = gensym('format')\n      scope[n] = fmts[node.format]\n\n      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)\n      else validate('if (!%s.test(%s)) {', n, name)\n      error('must be '+node.format+' format')\n      validate('}')\n      if (type !== 'string' && formats[node.format]) validate('}')\n    }\n\n    if (Array.isArray(node.required)) {\n      var isUndefined = function(req) {\n        return genobj(name, req) + ' === undefined'\n      }\n\n      var checkRequired = function (req) {\n        var prop = genobj(name, req);\n        validate('if (%s === undefined) {', prop)\n        error('is required', prop)\n        validate('missing++')\n        validate('}')\n      }\n      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')\n      validate('var missing = 0')\n      node.required.map(checkRequired)\n      validate('}');\n      if (!greedy) {\n        validate('if (missing === 0) {')\n        indent++\n      }\n    }\n\n    if (node.uniqueItems) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n      validate('if (!(unique(%s))) {', name)\n      error('must be unique')\n      validate('}')\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.enum) {\n      var complex = node.enum.some(function(e) {\n        return typeof e === 'object'\n      })\n\n      var compare = complex ?\n        function(e) {\n          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'\n        } :\n        function(e) {\n          return name+' !== '+JSON.stringify(e)\n        }\n\n      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')\n      error('must be an enum value')\n      validate('}')\n    }\n\n    if (node.dependencies) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      Object.keys(node.dependencies).forEach(function(key) {\n        var deps = node.dependencies[key]\n        if (typeof deps === 'string') deps = [deps]\n\n        var exists = function(k) {\n          return genobj(name, k) + ' !== undefined'\n        }\n\n        if (Array.isArray(deps)) {\n          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')\n          error('dependencies not set')\n          validate('}')\n        }\n        if (typeof deps === 'object') {\n          validate('if (%s !== undefined) {', genobj(name, key))\n          visit(name, deps, reporter, filter)\n          validate('}')\n        }\n      })\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.additionalProperties || node.additionalProperties === false) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      var i = genloop()\n      var keys = gensym('keys')\n\n      var toCompare = function(p) {\n        return keys+'['+i+'] !== '+JSON.stringify(p)\n      }\n\n      var toTest = function(p) {\n        return '!'+patterns(p)+'.test('+keys+'['+i+'])'\n      }\n\n      var additionalProp = Object.keys(properties || {}).map(toCompare)\n        .concat(Object.keys(node.patternProperties || {}).map(toTest))\n        .join(' && ') || 'true'\n\n      validate('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n          ('if (%s) {', additionalProp)\n\n      if (node.additionalProperties === false) {\n        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')\n        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')\n      } else {\n        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)\n      }\n\n      validate\n          ('}')\n        ('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.$ref) {\n      var sub = get(root, opts && opts.schemas || {}, node.$ref)\n      if (sub) {\n        var fn = cache[node.$ref]\n        if (!fn) {\n          cache[node.$ref] = function proxy(data) {\n            return fn(data)\n          }\n          fn = compile(sub, cache, root, false, opts)\n        }\n        var n = gensym('ref')\n        scope[n] = fn\n        validate('if (!(%s(%s))) {', n, name)\n        error('referenced schema does not match')\n        validate('}')\n      }\n    }\n\n    if (node.not) {\n      var prev = gensym('prev')\n      validate('var %s = errors', prev)\n      visit(name, node.not, false, filter)\n      validate('if (%s === errors) {', prev)\n      error('negative schema matches')\n      validate('} else {')\n        ('errors = %s', prev)\n      ('}')\n    }\n\n    if (node.items && !tuple) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      var i = genloop()\n      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)\n      visit(name+'['+i+']', node.items, reporter, filter)\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.patternProperties) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n      var keys = gensym('keys')\n      var i = genloop()\n      validate\n        ('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n\n      Object.keys(node.patternProperties).forEach(function(key) {\n        var p = patterns(key)\n        validate('if (%s.test(%s)) {', p, keys+'['+i+']')\n        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)\n        validate('}')\n      })\n\n      validate('}')\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.pattern) {\n      var p = patterns(node.pattern)\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n      validate('if (!(%s.test(%s))) {', p, name)\n      error('pattern mismatch')\n      validate('}')\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.allOf) {\n      node.allOf.forEach(function(sch) {\n        visit(name, sch, reporter, filter)\n      })\n    }\n\n    if (node.anyOf && node.anyOf.length) {\n      var prev = gensym('prev')\n\n      node.anyOf.forEach(function(sch, i) {\n        if (i === 0) {\n          validate('var %s = errors', prev)\n        } else {\n          validate('if (errors !== %s) {', prev)\n            ('errors = %s', prev)\n        }\n        visit(name, sch, false, false)\n      })\n      node.anyOf.forEach(function(sch, i) {\n        if (i) validate('}')\n      })\n      validate('if (%s !== errors) {', prev)\n      error('no schemas match')\n      validate('}')\n    }\n\n    if (node.oneOf && node.oneOf.length) {\n      var prev = gensym('prev')\n      var passes = gensym('passes')\n\n      validate\n        ('var %s = errors', prev)\n        ('var %s = 0', passes)\n\n      node.oneOf.forEach(function(sch, i) {\n        visit(name, sch, false, false)\n        validate('if (%s === errors) {', prev)\n          ('%s++', passes)\n        ('} else {')\n          ('errors = %s', prev)\n        ('}')\n      })\n\n      validate('if (%s !== 1) {', passes)\n      error('no (or more than one) schemas match')\n      validate('}')\n    }\n\n    if (node.multipleOf !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)\n\n      error('has a remainder')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maxProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)\n      error('has more properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.minProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)\n      error('has less properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.maxItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length > %d) {', name, node.maxItems)\n      error('has more items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.minItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length < %d) {', name, node.minItems)\n      error('has less items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.maxLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length > %d) {', name, node.maxLength)\n      error('has longer length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length < %d) {', name, node.minLength)\n      error('has less length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minimum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)\n      error('is less than minimum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maximum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)\n      error('is more than maximum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (properties) {\n      Object.keys(properties).forEach(function(p) {\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)\n\n        visit(genobj(name, p), properties[p], reporter, filter)\n\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')\n      })\n    }\n\n    while (indent--) validate('}')\n  }\n\n  var validate = genfun\n    ('function validate(data) {')\n      // Since undefined is not a valid JSON value, we coerce to null and other checks will catch this\n      ('if (data === undefined) data = null')\n      ('validate.errors = null')\n      ('var errors = 0')\n\n  visit('data', schema, reporter, opts && opts.filter)\n\n  validate\n      ('return errors === 0')\n    ('}')\n\n  validate = validate.toFunction(scope)\n  validate.errors = null\n\n  if (Object.defineProperty) {\n    Object.defineProperty(validate, 'error', {\n      get: function() {\n        if (!validate.errors) return ''\n        return validate.errors.map(function(err) {\n          return err.field + ' ' + err.message;\n        }).join('\\n')\n      }\n    })\n  }\n\n  validate.toJSON = function() {\n    return schema\n  }\n\n  return validate\n}\n\nmodule.exports = function(schema, opts) {\n  if (typeof schema === 'string') schema = JSON.parse(schema)\n  return compile(schema, {}, schema, true, opts)\n}\n\nmodule.exports.filter = function(schema, opts) {\n  var validate = module.exports(schema, xtend(opts, {filter: true}))\n  return function(sch) {\n    validate(sch)\n    return sch\n  }\n}\n"
        },
        {
          "id": 2,
          "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\generate-function\\index.js",
          "name": "./~/generate-function/index.js",
          "index": 4,
          "index2": 2,
          "size": 1180,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "issuerId": 1,
          "issuerName": "./~/is-my-json-valid/index.js",
          "profile": {
            "factory": 20,
            "building": 10
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
              "module": "./~/is-my-json-valid/index.js",
              "moduleName": "./~/is-my-json-valid/index.js",
              "type": "cjs require",
              "userRequest": "generate-function",
              "loc": "2:13-41"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 2,
          "source": "var INDENT_START = /[\\{\\[]/\nvar INDENT_END = /[\\}\\]]/\n\nmodule.exports = function() {\n  var lines = []\n  var indent = 0\n\n  var push = function(str) {\n    var spaces = ''\n    while (spaces.length < indent*2) spaces += '  '\n    lines.push(spaces+str)\n  }\n\n  var line = function(fmt) {\n    if (!fmt) return line\n\n    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {\n      indent--\n      push(arguments[0])\n      indent++\n      return line\n    }\n    if (INDENT_START.test(fmt[fmt.length-1])) {\n      push(arguments[0])\n      indent++\n      return line\n    }\n    if (INDENT_END.test(fmt.trim()[0])) {\n      indent--\n      push(arguments[0])\n      return line\n    }\n\n    push(arguments[0])\n    return line\n  }\n\n  line.toString = function() {\n    return lines.join('\\n')\n  }\n\n  line.toFunction = function(scope) {\n    var src = 'return ('+line.toString()+')'\n\n    var keys = Object.keys(scope || {}).map(function(key) {\n      return key\n    })\n\n    var vals = keys.map(function(key) {\n      return scope[key]\n    })\n\n    return Function.apply(null, keys.concat(src)).apply(null, vals)\n  }\n\n  if (arguments.length) line.apply(null, arguments)\n\n  return line\n}\n"
        },
        {
          "id": 3,
          "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\generate-object-property\\index.js",
          "name": "./~/generate-object-property/index.js",
          "index": 3,
          "index2": 1,
          "size": 290,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "issuerId": 1,
          "issuerName": "./~/is-my-json-valid/index.js",
          "profile": {
            "factory": 20,
            "building": 0
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
              "module": "./~/is-my-json-valid/index.js",
              "moduleName": "./~/is-my-json-valid/index.js",
              "type": "cjs require",
              "userRequest": "generate-object-property",
              "loc": "1:13-48"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 2,
          "source": "var isProperty = function(){return false};\n\nvar gen = function(obj, prop) {\n  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'\n}\n\ngen.valid = isProperty\ngen.property = function (prop) {\n return isProperty(prop) ? prop : JSON.stringify(prop)\n}\n\nmodule.exports = gen\n"
        },
        {
          "id": 4,
          "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\formats.js",
          "name": "./~/is-my-json-valid/formats.js",
          "index": 7,
          "index2": 5,
          "size": 2349,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "issuerId": 1,
          "issuerName": "./~/is-my-json-valid/index.js",
          "profile": {
            "factory": 0,
            "building": 10
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
              "module": "./~/is-my-json-valid/index.js",
              "moduleName": "./~/is-my-json-valid/index.js",
              "type": "cjs require",
              "userRequest": "./formats",
              "loc": "5:14-34"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 2,
          "source": "exports['date-time'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?([zZ]|[+-]\\d{2}:\\d{2})$/\nexports['date'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/\nexports['time'] = /^\\d{2}:\\d{2}:\\d{2}$/\nexports['email'] = /^\\S+@\\S+$/\nexports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/\nexports['ipv6'] = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/\nexports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/\nexports['color'] = /(#?([0-9A-Fa-f]{3,6})\\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\))/\nexports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$/\nexports['alpha'] = /^[a-zA-Z]+$/\nexports['alphanumeric'] = /^[a-zA-Z0-9]+$/\nexports['style'] = /\\s*(.+?):\\s*([^;]+);?/g\nexports['phone'] = /^\\+(?:[0-9] ?){6,14}[0-9]$/\nexports['utc-millisec'] = /^[0-9]{1,15}\\.?[0-9]{0,15}$/\n"
        },
        {
          "id": 5,
          "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\jsonpointer\\jsonpointer.js",
          "name": "./~/jsonpointer/jsonpointer.js",
          "index": 5,
          "index2": 3,
          "size": 2268,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "issuerId": 1,
          "issuerName": "./~/is-my-json-valid/index.js",
          "profile": {
            "factory": 20,
            "building": 10
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
              "module": "./~/is-my-json-valid/index.js",
              "moduleName": "./~/is-my-json-valid/index.js",
              "type": "cjs require",
              "userRequest": "jsonpointer",
              "loc": "3:18-40"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 2,
          "source": "var hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object') return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n"
        },
        {
          "id": 6,
          "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\xtend\\immutable.js",
          "name": "./~/xtend/immutable.js",
          "index": 6,
          "index2": 4,
          "size": 384,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "issuerId": 1,
          "issuerName": "./~/is-my-json-valid/index.js",
          "profile": {
            "factory": 20,
            "building": 10
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [
            {
              "moduleId": 1,
              "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
              "module": "./~/is-my-json-valid/index.js",
              "moduleName": "./~/is-my-json-valid/index.js",
              "type": "cjs require",
              "userRequest": "xtend",
              "loc": "4:12-28"
            }
          ],
          "usedExports": true,
          "providedExports": null,
          "depth": 2,
          "source": "module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n"
        },
        {
          "id": 7,
          "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "name": "./src/core.tsx",
          "index": 0,
          "index2": 7,
          "size": 69330,
          "cacheable": true,
          "built": true,
          "optional": false,
          "prefetched": false,
          "chunks": [
            0
          ],
          "assets": [],
          "issuer": null,
          "issuerId": null,
          "issuerName": null,
          "profile": {
            "factory": 20,
            "building": 3430
          },
          "failed": false,
          "errors": 0,
          "warnings": 0,
          "reasons": [],
          "usedExports": true,
          "providedExports": null,
          "depth": 0,
          "source": "\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) {\n            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n    }\n    return t;\n};\nvar __rest = this && this.__rest || function (s, e) {\n    var t = {};\n    for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n        if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n    }return t;\n};\nvar React = require(\"react\");\nvar react_1 = require(\"react\");\nvar objKeys = Object.keys; // getOwnPropertyNames\nvar isArr = Array.isArray;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar SymbolData = Symbol.for('FFormData');\nvar SymbolRecalc = Symbol.for('FFormRecalc');\nvar SymbolArray = Symbol.for('FFormArray');\nvar SymbolMap = Symbol.for('FFormMap');\nvar SymbolDelete = Symbol.for('FFormDelete');\nvar formReducerValue = 'forms';\n//const SymbolFor = Symbol.for;\nvar validator = require('is-my-json-valid');\nfunction objKeysAndSymbols(obj) {\n    var result = objKeys(obj);\n    return result.concat(Object.getOwnPropertySymbols(obj));\n}\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        return objKeys(baseCtor.prototype).forEach(function (name) {\n            return derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n/////////////////////////////////////////////\n//  Hooks\n/////////////////////////////////////////////\nfunction hookManager() {\n    var globalHooks = {};\n    var Hooks = {};\n    function setHook(name, hookName, hook) {\n        if (!Hooks[name]) Hooks[name] = {};\n        if (!Hooks[name][hookName]) Hooks[name][hookName] = globalHooks[hookName].slice();\n        Hooks[name][hookName].push(hook);\n    }\n    var add = function add(name, hookName, hook) {\n        if (name == '') {\n            if (!globalHooks[hookName]) globalHooks[hookName] = [];\n            objKeys(Hooks).forEach(function (key) {\n                return setHook(key, hookName, hook);\n            });\n            globalHooks[hookName].push(hook);\n        } else setHook(name, hookName, hook);\n        return remove.bind(null, name, hookName, hook);\n    };\n    function remove(name, hookName, hook) {\n        if (name == '') {\n            globalHooks[hookName].splice(globalHooks[hookName].indexOf(hook), 1);\n            objKeys(Hooks).forEach(function (key) {\n                return Hooks[key][hookName].splice(Hooks[key][hookName].indexOf(hook));\n            }, 1);\n        } else Hooks[name][hookName].splice(Hooks[name][hookName].indexOf(hook), 1);\n    }\n    ;\n    // add.remove = remove;\n    add.get = function (name) {\n        return Hooks[name];\n    };\n    return add;\n}\nvar Hooks = hookManager();\nexports.addHook = Hooks;\n// update children\nHooks('', 'beforeMerge', function (item, state, data, utils) {\n    var res = { result: true };\n    if (item[1][0] == 'paramSwitcher' && item[1].length == 2) {\n        res.result = false;\n        res.changes = object2PathValues(getIn(state, item[0])).map(function (pathValue) {\n            pathValue.pop();\n            var keyPath = item[1].slice();\n            keyPath[0] = 'param';\n            return [pathValue, keyPath, item[2]];\n        });\n    }\n    return res;\n});\n// recalc array\nHooks('', 'beforeMerge', function (item, state, data, utils) {\n    if (item[1][0] == 'length') {\n        if (!data[SymbolArray]) data[SymbolArray] = {};\n        data[SymbolArray][path2string(item[0])] = { path: item[0] };\n    }\n    return true;\n});\n// set data for parent\nHooks('', 'beforeMerge', function (item, state, data, utils) {\n    var result = true;\n    var changes = [];\n    // if(!data[SymbolRecalc]) data[SymbolRecalc] = {};\n    if (item[1][0] == 'status' && item[1].length == 2) {\n        var param = item[1][1];\n        var checkValue = param == 'valid' || param == 'pristine'; // true for valid and pristine\n        // if(getIn(state, item[0].concat(SymbolData).concat(item[1])))\n        var checkItem = item[2] == checkValue ? SymbolRecalc : item[2];\n        var path = item[0].slice();\n        for (var i = 0; i < item[0].length; i++) {\n            path.pop();\n            changes.push([path, item[1], checkItem]);\n            if ((typeof checkItem === \"undefined\" ? \"undefined\" : _typeof2(checkItem)) == 'symbol') {\n                if (!data[SymbolRecalc]) data[SymbolRecalc] = {};\n                if (!data[SymbolRecalc][path.length]) data[SymbolRecalc][path.length] = {};\n                if (!data[SymbolRecalc].length || data[SymbolRecalc].length < path.length) data[SymbolRecalc].length = path.length;\n                data[SymbolRecalc][path.length][path2string(path, item[1])] = {\n                    path: path,\n                    keyPath: item[1],\n                    checkValue: checkValue\n                };\n            }\n        }\n    }\n    return { result: result, changes: changes, data: data };\n});\n// Recalculate\nHooks('', 'beforeMap', function (stateObject, utils, data) {\n    var changes = [];\n    if (data[SymbolRecalc]) {\n        (function () {\n            var newVals = {};\n            var state = stateObject.next;\n            var recalcArray = data[SymbolRecalc];\n\n            var _loop = function _loop(i) {\n                var obj = recalcArray[recalcArray.length - i - 1];\n                if (obj) {\n                    objKeys(obj).forEach(function (key) {\n                        var _obj$key = obj[key],\n                            path = _obj$key.path,\n                            keyPath = _obj$key.keyPath,\n                            checkValue = _obj$key.checkValue;\n\n                        var keys = objKeys(getIn(state, path));\n                        var result = checkValue;\n                        for (var j = 0; j < keys.length; j++) {\n                            var pathString = path2string(path.concat(keys[j]), keyPath);\n                            var value = newVals.hasOwnProperty(pathString) ? newVals[pathString] : utils.get(state, pathString);\n                            if (value != checkValue) {\n                                result = !checkValue;\n                                break;\n                            }\n                        }\n                        changes.push([path, keyPath, result]);\n                        newVals[key] = result;\n                        // state = mergeState(state, makeSlice(push2array(path, SymbolData, keyPath, result))).state;\n                    });\n                }\n            };\n\n            for (var i = 0; i < recalcArray.length; i++) {\n                _loop(i);\n            }\n        })();\n    }\n    return changes;\n});\n// Array add/remove \nHooks('', 'beforeMap', function (stateObject, utils, data) {\n    var changes = [];\n    if (data[SymbolArray]) {\n        objKeys(data[SymbolArray]).forEach(function (key) {\n            var path = data[SymbolArray][key].path;\n\n            var state = stateObject.next;\n            var schema = state[SymbolData].schema;\n            var pathLength = path.concat(SymbolData, length);\n            var start = getIn(stateObject.prev, pathLength);\n            var end = getIn(stateObject.next, pathLength);\n            if (start < end) {\n                for (var i = start; i < end; i++) {\n                    var elemPath = path.concat(i);\n                    var dataObj = getIn(stateObject.next, elemPath);\n                    if (!dataObj) dataObj = {};\n                    var newElem = makeDataObject(schema, elemPath);\n                    dataObj = mergeState(dataObj, newElem.data).state;\n                    changes.push([elemPath, dataObj]);\n                    changes.push([[SymbolData, 'valueMap'], newElem.valueMap]);\n                }\n            }\n            if (start > end) {\n                for (var _i = end; _i < start; _i++) {\n                    changes.push([path.concat(_i), SymbolDelete]);\n                }\n            }\n        });\n    }\n    return changes;\n});\n/////////////////////////////////////////////\n//  Api class\n/////////////////////////////////////////////\n\nvar apiMixin = function () {\n    function apiMixin() {\n        _classCallCheck(this, apiMixin);\n\n        this.utils = utils;\n    }\n\n    _createClass(apiMixin, [{\n        key: \"initState\",\n        value: function initState(props, setStateFunc) {\n            var self = this;\n            if (!self.reducer) self.reducer = formReducer();\n            self.keyMap = makeKeyMapFromSchema(props.schema);\n            var formValues = props.formValues || {};\n\n            var _makeStateFromSchema = makeStateFromSchema(props.schema),\n                state = _makeStateFromSchema.state,\n                valueMap = _makeStateFromSchema.valueMap;\n\n            state[SymbolData]['valueMap'] = valueMap;\n            state[SymbolData]['name'] = props.name;\n            state = mergeState(state, [state, props.state || {}], {\n                symbol: true,\n                clear: true\n            }).state;\n            self.setNewState = setStateFunc;\n            self.setNewState(state);\n        }\n    }, {\n        key: \"_dispath\",\n        value: function _dispath(action) {\n            var self = this;\n            try {\n                self.isDispatching = true;\n                self.setNewState(self.reducer(self.currentState, action));\n            } finally {\n                self.isDispatching = false;\n            }\n            return action;\n        }\n    }]);\n\n    return apiMixin;\n}();\n\nvar makeApi = function (_apiMixin) {\n    _inherits(makeApi, _apiMixin);\n\n    function makeApi(props) {\n        _classCallCheck(this, makeApi);\n\n        var _this = _possibleConstructorReturn(this, (makeApi.__proto__ || Object.getPrototypeOf(makeApi)).call(this));\n\n        var self = _this;\n        self.initState(props, self.setState);\n        self.api = apiCreator(self._dispath, self.getState, self.keyMap, Hooks.get(props.name));\n        return _this;\n    }\n\n    _createClass(makeApi, [{\n        key: \"setState\",\n        value: function setState(state) {\n            this.currentState = state;\n        }\n    }, {\n        key: \"getState\",\n        value: function getState() {\n            return this.currentState;\n        }\n    }]);\n\n    return makeApi;\n}(apiMixin);\n\nexports.makeApi = makeApi;\n/////////////////////////////////////////////\n//  Main class\n/////////////////////////////////////////////\n\nvar Form = function (_react_1$PureComponen) {\n    _inherits(Form, _react_1$PureComponen);\n\n    /*  static propTypes = {\r\n     shchema: PropTypes.object.isRequired,\r\n     name: PropTypes.string,\r\n     store: PropTypes.object,\r\n     dispath: PropTypes.func,\r\n     values: PropTypes.object,\r\n     initalValues: PropTypes.object,\r\n     defaultValues: PropTypes.object,\r\n     };*/\n    function Form(props, context) {\n        _classCallCheck(this, Form);\n\n        var _this2 = _possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props, context));\n\n        var self = _this2;\n        var formValues = props.formValues,\n            state = props.state,\n            schema = props.schema,\n            name = props.name;\n\n        self.store = props.store;\n        self._setIface(props.iface);\n        self.schema = resolveSchema(schema);\n        self.initState({ formValues: formValues, state: state, schema: self.schema, name: name }, self.setState);\n        return _this2;\n    }\n\n    _createClass(Form, [{\n        key: \"shouldComponentUpdate\",\n        value: function shouldComponentUpdate(newProps) {\n            var self = this;\n            if (!isEqual(this.props, newProps, { skipKeys: ['state', 'store', 'iface'] })) {\n                if (this.props.store != newProps.store) this.store = newProps.store;\n                if (this.props.iface != newProps.iface || this.props.store != newProps.store) this._setIface(newProps.iface);\n                self.setState(newProps.state);\n                return false;\n            }\n            return true;\n        }\n    }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n            if (this.unsubscribe) this.unsubscribe();\n        }\n    }, {\n        key: \"_handleChange\",\n        value: function _handleChange() {\n            var self = this;\n            var nextState = self.store.getState()[formReducerValue][self.props.name];\n            if (nextState !== self.currentState) {\n                self.setState(nextState);\n            }\n        }\n    }, {\n        key: \"setState\",\n        value: function setState(state) {\n            if (this.currentState != state) {\n                var prevVersion = this.currentState[SymbolData].version;\n                this.currentState = state;\n                if (this.refs && this.refs['main']) this.refs['main']['_update'](state[SymbolData].version == prevVersion + 1);\n            }\n        }\n    }, {\n        key: \"_setIface\",\n        value: function _setIface(iface) {\n            var self = this;\n            if (!iface) iface = self.context.store || self.store ? 'redux' : 'local';\n            self.iface = iface;\n            if (self.iface == 'redux') {\n                var store = void 0;\n                if (self.store) store = self.store;else if (self.context.store) store = self.store = self.context.store;else throw new Error('In redux mode store must be provided either in context or in props.store');\n                self.dispath = store.dispath;\n                if (self.unsubscribe) self.unsubscribe();\n                self.unsubscribe = store.subscribe(self._handleChange);\n            } else {\n                if (self.unsubscribe) {\n                    self.unsubscribe();\n                    delete self.unsubscribe;\n                }\n                self.dispath = self._dispath;\n            }\n            self.api = apiCreator(self.dispath, function () {\n                return self.currentState;\n            }, self.keyMap, Hooks.get(self.props.name));\n        }\n    }, {\n        key: \"setFocus\",\n        value: function setFocus(path) {}\n    }, {\n        key: \"getState\",\n        value: function getState() {\n            return this.currentState;\n        }\n    }, {\n        key: \"render\",\n        value: function render() {\n            var self = this;\n            var _a = self.props,\n                name = _a.name,\n                formObjects = _a.formObjects,\n                formValues = _a.formValues,\n                schema = _a.schema,\n                iface = _a.iface,\n                Tag = _a.tag,\n                state = _a.state,\n                store = _a.store,\n                rest = __rest(_a, [\"name\", \"formObjects\", \"formValues\", \"schema\", \"iface\", \"tag\", \"state\", \"store\"]);\n            var form = {};\n            form.name = name;\n            form.formObjects = formObjects;\n            form.schema = self.schema;\n            form.api = self.api;\n            form.utils = self.utils;\n            if (!Tag) Tag = React.DOM.form;\n            // <Section ref=\"main\" path={[]} form={form}/>\n            // {...(formProps.shchema.id ? {id: formProps.shchema.id} : {})}\n            return React.createElement(Tag, __assign({}, rest, { name: name }), React.createElement(Field, { form: form, path: [] }), \";\");\n        }\n    }]);\n\n    return Form;\n}(react_1.PureComponent);\n\nForm.contextTypes = {\n    store: React.PropTypes.object\n};\nexports.Form = Form;\napplyMixins(Form, [apiMixin]);\n/////////////////////////////////////////////\n//  Section class\n/////////////////////////////////////////////\n\nvar Section = function (_react_1$Component) {\n    _inherits(Section, _react_1$Component);\n\n    function Section(props, context) {\n        _classCallCheck(this, Section);\n\n        var _this3 = _possibleConstructorReturn(this, (Section.__proto__ || Object.getPrototypeOf(Section)).call(this, props, context));\n\n        _this3.layouts = [];\n        _this3.ArrayItem = _this3._makeArrayItem();\n        _this3._build();\n        return _this3;\n    }\n\n    _createClass(Section, [{\n        key: \"_update\",\n        value: function _update() {}\n    }, {\n        key: \"_makeArrayItem\",\n        value: function _makeArrayItem() {\n            var formObjects = this.props.formObjects;\n\n            var Tag = React.DOM.div;\n            var _a = formObjects['Item'] || {},\n                _a$tag = _a.tag,\n                Item = _a$tag === undefined ? Tag : _a$tag,\n                itemRest = __rest(_a, [\"tag\"]);var _b = formObjects['ItemBody'] || {},\n                _b$tag = _b.tag,\n                ItemBody = _b$tag === undefined ? Tag : _b$tag,\n                itemBodyRest = __rest(_b, [\"tag\"]);var _c = formObjects['ItemMenu'] || {},\n                _c$tag = _c.tag,\n                ItemMenu = _c$tag === undefined ? Tag : _c$tag,\n                itemMenuRest = __rest(_c, [\"tag\"]);\n            return function (props) {\n                return React.createElement(Item, null, React.createElement(ItemBody, null, React.Children.only(props.childen)), React.createElement(ItemMenu, null));\n            };\n        }\n    }, {\n        key: \"_build\",\n        value: function _build() {\n            var self = this;\n            var _self$props = self.props,\n                path = _self$props.path,\n                form = _self$props.form;\n\n            var schemaPart = getSchemaPart(form.schema, path);\n            if (!schemaPart) return null;\n            var _schemaPart$x = schemaPart.x,\n                x = _schemaPart$x === undefined ? {} : _schemaPart$x,\n                _schemaPart$propertie = schemaPart.properties,\n                properties = _schemaPart$propertie === undefined ? {} : _schemaPart$propertie;\n            var _x$layoutsGroup = x.layoutsGroup,\n                layoutsGroup = _x$layoutsGroup === undefined ? [] : _x$layoutsGroup;\n\n            var keys = [];\n            var ArrayItem = false;\n            if (schemaPart.type == 'array') {\n                var _length = form.api.getSingle(path.concat(SymbolData, 'length')) || [];\n                for (var i = 0; i < _length; i++) {\n                    keys.push(i);\n                }ArrayItem = this.ArrayItem;\n            } else {\n                keys = objKeys(schemaPart.properties);\n            }\n            layoutsGroup.forEach(function (layout) {\n                var _layout$fields = layout.fields,\n                    fields = _layout$fields === undefined ? [] : _layout$fields;\n\n                if (!isArr(fields)) fields = fields.trim().replace(/\\s+/, ',').split(',');\n                fields.forEach(function (field) {\n                    self.layouts.push(ArrayItem ? React.createElement(ArrayItem, { rel: 'array_' + field }, React.createElement(Field, { form: form, path: path.concat(field) })) : React.createElement(Field, { form: form, path: path.concat(field) }));\n                    keys.splice(keys.indexOf(field), 1);\n                });\n            });\n            keys.forEach(function (field) {\n                self.layouts.push(ArrayItem ? React.createElement(ArrayItem, { rel: 'array_' + field }, React.createElement(Field, { form: form, path: path.concat(field) })) : React.createElement(Field, { form: form, path: path.concat(field) }));\n            });\n        }\n    }, {\n        key: \"render\",\n        value: function render() {\n            var _a = this.props,\n                _a$tag2 = _a.tag,\n                Tag = _a$tag2 === undefined ? React.DOM.div : _a$tag2,\n                form = _a.form,\n                path = _a.path,\n                rest = __rest(_a, [\"tag\", \"form\", \"path\"]);\n            return React.createElement(Tag, __assign({}, rest), this.layouts);\n        }\n    }]);\n\n    return Section;\n}(react_1.Component);\n/////////////////////////////////////////////\n//  Field class\n/////////////////////////////////////////////\n\n\nvar Field = function (_react_1$Component2) {\n    _inherits(Field, _react_1$Component2);\n\n    function Field() {\n        _classCallCheck(this, Field);\n\n        return _possibleConstructorReturn(this, (Field.__proto__ || Object.getPrototypeOf(Field)).apply(this, arguments));\n    }\n\n    _createClass(Field, [{\n        key: \"_build\",\n        value: function _build() {}\n    }, {\n        key: \"render\",\n        value: function render() {\n            function getProps(name) {\n                var result = mergeState(formObjects[name]['*'] || {}, [formObjects[name][type] || {}, x.custom && x.custom[name] || {}], { skipKeys: ['propsMapAdd'] });\n                var propsMapAdd = [];\n                push2array(propsMapAdd, result['propsMap'] || []);\n                push2array(propsMapAdd, formObjects[name]['*'] && formObjects[name]['*']['propsMapAdd'] || []);\n                push2array(propsMapAdd, formObjects[name][type] && formObjects[name][type]['propsMapAdd'] || []);\n                push2array(propsMapAdd, x.custom && x.custom[name] && x.custom[name]['propsMapAdd'] || []);\n                result['propsMap'] = propsMapAdd;\n                return result;\n                // return x.custom && x.custom[name] || formObjects[name][type] || formObjects[name]['*'] || {};\n            }\n            function mapProps(map, data) {\n                var result = {};\n                map.forEach(function (item) {\n                    if (!isArr(item)) item = [item, item];\n                    result[item[1]] = getIn(data, string2path(item[0]));\n                    var fn = item[2];\n                    if (fn) result[item[1]] = fn(api, result[item[1]]);\n                });\n                return result;\n            }\n            var _props = this.props,\n                form = _props.form,\n                path = _props.path;\n            var schema = form.schema,\n                formObjects = form.formObjects,\n                api = form.api,\n                utils = form.utils;\n\n            var schemaPart = getSchemaPart(schema, path);\n            var type = isArr(schemaPart.type) ? schemaPart.type[0] : schemaPart.type;\n            var x = schemaPart.x || {};\n            var _a = getProps('title'),\n                _a$tag3 = _a.tag,\n                TitleTag = _a$tag3 === undefined ? React.DOM.div : _a$tag3,\n                titlePropsMap = _a.propsMap,\n                titleProps = __rest(_a, [\"tag\", \"propsMap\"]);var _b = getProps('body'),\n                _b$tag2 = _b.tag,\n                BodyTag = _b$tag2 === undefined ? React.DOM.div : _b$tag2,\n                bodyPropsMap = _b.propsMap,\n                bodyProps = __rest(_b, [\"tag\", \"propsMap\"]);var _c = getProps('message'),\n                _c$tag2 = _c.tag,\n                MessageTag = _c$tag2 === undefined ? React.DOM.div : _c$tag2,\n                messagePropsMap = _c.propsMap,\n                messageProps = __rest(_c, [\"tag\", \"propsMap\"]);var _d = getProps('layout'),\n                layoutPropsMap = _d.propsMap,\n                layoutProps = __rest(_d, [\"propsMap\"]);\n            var MainTag = void 0;\n            var mainProps = void 0;\n            var mainPropsMap = [];\n            if (schemaPart.type == 'object' || schemaPart.type == 'array') {\n                MainTag = Section;\n                mainProps = getProps('main');\n                mainProps.form = form;\n                mainProps.path = path;\n            } else {\n                mainProps = getProps('main');\n                MainTag = mainProps.tag || React.DOM.div;\n                mainPropsMap = mainProps.propsMap;\n                mainProps = without(mainProps, false, ['tag', 'propsMap']);\n            }\n            var data = api.getSingle(path.concat(SymbolData));\n            var layoutData = mapProps(layoutPropsMap, data);\n            var mainData = mapProps(mainPropsMap, data);\n            var titleData = mapProps(titlePropsMap, data);\n            var bodyData = mapProps(bodyPropsMap, data);\n            var messageData = mapProps(messagePropsMap, data);\n            return React.createElement(Layout, __assign({ layout: layoutProps }, layoutData), React.createElement(TitleTag, __assign({}, titleProps, titleData), data.schemaData.title || ''), React.createElement(BodyTag, __assign({}, bodyProps, bodyData), React.createElement(MainTag, __assign({}, mainProps, mainData))), React.createElement(MessageTag, __assign({}, messageProps, messageData)));\n        }\n    }]);\n\n    return Field;\n}(react_1.Component);\n/////////////////////////////////////////////\n//  Basic components\n/////////////////////////////////////////////\n\n\nfunction Layout(_ref) {\n    var layout = _ref.layout,\n        children = _ref.children;\n\n    var _layout$style = layout.style,\n        style = _layout$style === undefined ? {} : _layout$style,\n        flexDirection = layout.flexDirection,\n        flex = layout.flex,\n        display = layout.display,\n        _layout$tag = layout.tag,\n        Tag = _layout$tag === undefined ? React.DOM.div : _layout$tag,\n        rest = __rest(layout, [\"style\", \"flexDirection\", \"flex\", \"display\", \"tag\"]);\n\n    style.display = display || style.display || 'flex';\n    style.flexDirection = flexDirection || style.flexDirection || 'column';\n    style.flex = flex || style.flex || '0 1 auto';\n    return React.createElement(Tag, __assign({ style: style }, rest), children);\n}\n/////////////////////////////////////////////\n//  Actions names\n/////////////////////////////////////////////\nvar actionsName = {};\nactionsName.setSingle = 'FFORM_SET_SINGLE';\nactionsName.setAsObject = 'FFORM_SET_AS_OBJECT';\n// actionsName.setAsSlice = 'FFORM_SET_AS_SLICE';\nactionsName.execBatch = 'FFORM_EXEC_BATCH';\n/////////////////////////////////////////////\n//  Actions function\n/////////////////////////////////////////////\nvar actions = {};\nactions.setSingle = function (path, value, keyMap, hooks) {\n    return { type: actionsName.setSingle, path: path, value: value, keyMap: keyMap, hooks: hooks };\n};\nactions.setAsObject = function (vals, keyPath, keyMap, hooks) {\n    return { type: actionsName.setAsObject, vals: vals, keyPath: keyPath, keyMap: keyMap, hooks: hooks };\n};\nactions.execBatch = function (batchedActions, hooks) {\n    return { type: actionsName.execBatch, batchedActions: batchedActions, hooks: hooks };\n};\n/////////////////////////////////////////////\n//  Reducer\n/////////////////////////////////////////////\nfunction formReducer(name) {\n    if (name) formReducerValue = name;\n    var reducersFunction = {};\n    // const utils: utilsApiType = {\n    //   get: (state: any, path: Path, keyPath: Path) => getIn(state, path.concat(SymbolData, keyPath)),\n    //   getIn,\n    //   isEqual\n    // };\n    function makeSliceFromUpdateItem(item) {\n        if (item.length == 3) return makeSlice(push2array(item[0], SymbolData, item[1], item[2]));else return makeSlice(push2array(item[0], item[1]));\n    }\n    function setChangesOnStateIfNeeded(state, resultObject, Hooks) {\n        var result = resultObject.result,\n            data = resultObject.data;\n\n        var mergeResult = mergeState(state, result);\n        ['afterMerge', 'beforeMap', 'applyMap', 'afterMap'].forEach(function (op) {\n            var fn = op == 'applyMap' ? applyMap : applyUpdateHooks;\n            var res = fn({\n                prev: state,\n                changes: mergeResult.changes,\n                next: mergeResult.state\n            }, data, Hooks[op]);\n            if (!res) return state; // all changes blocked\n            if (res.length) {\n                result = result.concat(res);\n                mergeResult = mergeState(state, result);\n            }\n        });\n        if (mergeResult.state != state) {\n            mergeResult.state[SymbolData]['version']++;\n            mergeResult.state[SymbolData]['changes'] = mergeResult.changes;\n        }\n        return mergeResult.state;\n    }\n    function applyMap(stateObject, additionalData) {\n        var result = [];\n        var valueMap = stateObject.next[SymbolData].valueMap;\n        var state = stateObject.next;\n        function recurse(changes) {\n            var track = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            var mapTo = getIn(valueMap, track.concat(SymbolMap));\n            if (mapTo) {\n                (function () {\n                    // value[path2string(to[0], to[1])] = {to, fn};\n                    var value = getIn(state, track);\n                    objKeys(mapTo).forEach(function (key) {\n                        var _mapTo$key = mapTo[key],\n                            to = _mapTo$key.to,\n                            fn = _mapTo$key.fn;\n\n                        if (fn) value = fn(state, utils, value);\n                        var updateItem = to[1] ? [to[0], to[1], value] : [to[0], value];\n                        result.push(updateItem);\n                    });\n                })();\n            }\n            objKeysAndSymbols(changes).forEach(function (key) {\n                return recurse(changes[key], track.concat(key));\n            });\n        }\n        recurse(stateObject.changes);\n        return result;\n    }\n    function applyUpdateHooks(stateObject, additionalData, hooks) {\n        var result = [];\n        for (var i = 0; i < hooks.length; i++) {\n            var res = hooks[i](stateObject, utils, additionalData);\n            if (!res) return false; // all changes blocked\n            res.forEach(function (item) {\n                return result.push(item);\n            });\n        }\n        return result;\n    }\n    function applyMergeHooks(item, state, data, hooks) {\n        var changes = [];\n        var result = true;\n        for (var i = 0; i < hooks.length; i++) {\n            var res = hooks[i](item, state, data, utils);\n            if (!res) return false;\n            if (res !== true) {\n                if (isArr(res)) res = { result: true, changes: res };\n                if (res.changes) res.changes.forEach(function (item) {\n                    return changes.push(item);\n                });\n                // if (res.data) data = mergeState(data, res.data).state;\n                result = res.result;\n            }\n        }\n        return { result: result, data: data, changes: changes };\n    }\n    function makePathValueSlicesForObject(state, action) {\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var vals = action.vals,\n            keyPath = action.keyPath,\n            keyMap = action.keyMap;\n\n        var items = object2PathValues(vals); // get array of pathValues where item.pop() - value\n        // let data = {};\n        var changes = [];\n        var result = [];\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i]; // item.pop() - value\n            var value = item.pop();\n            item = keyMap.key2path(item); // resolve key to path\n            if (getIn(state, item.concat(SymbolData, keyPath)) != value) {\n                var res = applyMergeHooks([item, keyPath, value], state, data, action.hooks.beforeMerge);\n                if (res) {\n                    if (res.result) result.push([item, keyPath, value]);\n                    if (res.changes) res.changes.forEach(function (item) {\n                        return changes.push(item);\n                    }); // additional changes\n                }\n            }\n        }\n        changes.forEach(function (item) {\n            return result.push(item);\n        }); // add changes to the end\n        return { result: result.map(function (item) {\n                return makeSliceFromUpdateItem(item);\n            }), data: data };\n    }\n    function makePathValueSlicesForSingle(state, action) {\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var value = action.value,\n            path = action.path,\n            keyMap = action.keyMap;\n\n        var items = object2PathValues(value); // get array of items, where item.pop() - value\n        var pathMapped = keyMap.key2path(path);\n        var result = [];\n        // let data = {};\n        var changes = [];\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            var _value = item.pop();\n            if (getIn(state, pathMapped.concat(SymbolData, item)) != _value) {\n                var res = applyMergeHooks([pathMapped, item, _value], state, data, action.hooks.beforeMerge);\n                if (res) {\n                    if (res.result) result.push([pathMapped, item, _value]);\n                    if (res.changes) res.changes.forEach(function (item) {\n                        return changes.push(item);\n                    }); // additional changes\n                }\n            }\n        }\n        changes.forEach(function (item) {\n            return result.push(item);\n        }); // add changes to the end\n        return { result: result.map(function (item) {\n                return makeSliceFromUpdateItem(item);\n            }), data: data };\n    }\n    reducersFunction[actionsName.setSingle] = function (state, action) {\n        var path = action.path.concat(SymbolData);\n        var pathValueSlices = makePathValueSlicesForSingle(state, action);\n        return setChangesOnStateIfNeeded(state, pathValueSlices, action.hooks);\n    };\n    reducersFunction[actionsName.setAsObject] = function (state, action) {\n        //let pathValueSlices: any[] = makePathValueSlicesForObject(action.vals, action.keyPath, action.keyMap);\n        var pathValueSlices = makePathValueSlicesForObject(state, action);\n        return setChangesOnStateIfNeeded(state, pathValueSlices, action.hooks);\n    };\n    reducersFunction[actionsName.execBatch] = function (state, action) {\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        var result = [];\n        // let data = {};\n        action.batchedActions.forEach(function (action) {\n            var fn = void 0;\n            if (action.type == actionsName.setSingle) fn = makePathValueSlicesForSingle;else if (action.type == actionsName.setAsObject) fn = makePathValueSlicesForObject;\n            var res = fn(state, action, data);\n            res.result.forEach(function (item) {\n                return result.push(item);\n            });\n            // data = mergeState(data, res.data).state\n        });\n        return setChangesOnStateIfNeeded(state, { result: result, data: data }, action.hooks); // setChangesOnStateIfNeeded(mergeState(state, pathValueSlices), state);\n    };\n    return function (state, action) {\n        var reduce = reducersFunction[action.type];\n        return reduce ? reduce(state, action) : state;\n    };\n}\nexports.formReducer = formReducer;\n/////////////////////////////////////////////\n//  API\n/////////////////////////////////////////////\nfunction apiCreator(dispath, getState, keyMap, hooks) {\n    function getAsSlices(store, keyPath, keyMap) {\n        var track = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n        var type = store[SymbolData].schemaData.type;\n        if (type == 'array') {\n            var _ret4 = function () {\n                var arr = [];\n                objKeys(store).forEach(function (key) {\n                    var childType = store[key][SymbolData].schemaData.type;\n                    if (childType == 'object' || childType == 'array') arr[key] = mergeState({}, getAsSlices(store[key], keyPath, keyMap)).state;else arr[key] = getIn(store[key][SymbolData], keyPath);\n                });\n                return {\n                    v: makeSlice(push2array(keyMap.path2key(track), arr))\n                };\n            }();\n\n            if ((typeof _ret4 === \"undefined\" ? \"undefined\" : _typeof2(_ret4)) === \"object\") return _ret4.v;\n        } else if (type == 'object') {\n            var _ret5 = function () {\n                var result = []; // (store[SymbolData].schemaData.type == 'array') ? [] : {};\n                objKeys(store).forEach(function (key) {\n                    return result.push(getAsSlices(store[key], keyPath, keyMap, track.concat(key)));\n                });\n                return {\n                    v: result\n                };\n            }();\n\n            if ((typeof _ret5 === \"undefined\" ? \"undefined\" : _typeof2(_ret5)) === \"object\") return _ret5.v;\n        } else {\n            return makeSlice(push2array(keyMap.path2key(track), getIn(store[SymbolData], keyPath)));\n        }\n    }\n    var api = {};\n    var batching = false;\n    var batchedActions = [];\n    var dispathAction = dispath;\n    api.getState = getState;\n    api.getSingle = function (path) {\n        return getIn(getState(), typeof path == 'string' ? string2path(path) : path);\n    };\n    api.setSingle = function (path, value) {\n        return dispathAction(actions.setSingle(typeof path == 'string' ? string2path(path) : path, value, keyMap, hooks));\n    };\n    api.getAsObject = function (keyPath) {\n        return mergeState({}, getAsSlices(getState(), keyPath, keyMap)).state;\n    };\n    api.setAsObject = function (vals, keyPath) {\n        return dispathAction(actions.setAsObject(vals, keyPath, keyMap, hooks));\n    };\n    api.getValues = function () {\n        return api.getAsObject(['values', 'current']);\n    };\n    api.setValues = function (vals) {\n        return api.setAsObject(vals, ['values', 'current']);\n    };\n    api.getPristine = function () {\n        return api.getAsObject(['values', 'pristine']);\n    };\n    api.setPristine = function (vals) {\n        return api.setAsObject(vals, ['values', 'pristine']);\n    };\n    api.getDefault = function () {\n        return api.getAsObject(['values', 'default']);\n    };\n    api.setDefault = function (vals) {\n        return api.setAsObject(vals, ['values', 'default']);\n    };\n    api.arrayAddItem = function (path) {};\n    api.arrayDelItem = function (path, index) {};\n    api.arrayMoveItem = function (path, from, to) {};\n    api.show = function (path) {};\n    api.hide = function (path) {};\n    api.showOnly = function (path) {};\n    api.startBatch = function () {\n        batching = true;\n        dispathAction = batchedActions.push;\n    };\n    api.execBatch = function () {\n        batching = false;\n        dispathAction = dispath;\n        dispath(actions.execBatch(batchedActions, hooks));\n        batchedActions = [];\n    };\n    return api;\n}\n/////////////////////////////////////////////\n//      Schema utilities\n/////////////////////////////////////////////\n// function getSchemaApi(schema: JsonSchema) {\n//   return {schema, getSchemaPart: getSchemaPart.bind(null, schema), makeDataObject: makeDataObject.bind(null, schema)};\n// };\nfunction getSchemaPart(resolvedSchema, path) {\n    function getArrayItemSchemaPart(index, schemaPart) {\n        var items = [];\n        if (schemaPart.items) {\n            if (!isArr(schemaPart.items)) return schemaPart.items;else items = schemaPart.items;\n        }\n        if (index < items.length) return items[index];else {\n            if (schemaPart.additionalItems) {\n                if (schemaPart.additionalItems !== true) return schemaPart.additionalItems;\n                return items[items.length - 1];\n            }\n        }\n        throw new Error(errorText + path.join('.'));\n    }\n    var errorText = 'Schema path not found: ';\n    var schemaPart = resolvedSchema;\n    for (var i = 0; i < path.length; i++) {\n        if (!schemaPart) throw new Error(errorText + path.join('.'));\n        if (schemaPart.type == 'array') {\n            schemaPart = getArrayItemSchemaPart(path[i], schemaPart);\n        } else {\n            if (schemaPart.properties && schemaPart.properties[path[i]]) schemaPart = schemaPart.properties[path[i]];else throw new Error(errorText + path.join('.'));\n            ;\n        }\n    }\n    return schemaPart;\n}\nfunction makeDataObject(resolvedSchema, path) {\n    function getValueFromParents(path, keyPath, resolvedSchema) {\n        var tmpPath = path.concat(null);\n        for (var i = 0; i < path.length + 1; i++) {\n            tmpPath.pop();\n            var _schemaPart = getSchemaPart(resolvedSchema, path);\n            if (_schemaPart) return getIn(_schemaPart, keyPath);\n        }\n    }\n    function getParentArrayValue(path, resolvedSchema) {\n        var pathPart = path.slice();\n        var keyPart = [];\n        var result = void 0;\n        for (var i = 0; i < path.length; i++) {\n            var key = pathPart.pop();\n            key.unshift(key);\n            var _schemaPart2 = getSchemaPart(resolvedSchema, pathPart);\n            if (!_schemaPart2) return;\n            if (_schemaPart2.type == 'array') {\n                var tmp = getIn(_schemaPart2.default, keyPart);\n                if (tmp) result = tmp;\n            }\n        }\n        return result;\n    }\n    function mergeValueMapArray2Object(valueMapArray) {\n        return mergeState({}, valueMapArray.map(function (item) {\n            var from = item[0];\n            var to = item[1];\n            var fn = item[2];\n            var pathValue = from[0].slice();\n            if (from[1]) push2array(pathValue, SymbolData, from[1]);\n            var value = {};\n            value[path2string(to[0], to[1])] = { to: to, fn: fn };\n            return makeSlice(push2array(pathValue, SymbolMap, value));\n        }));\n    }\n    var schemaPart = getSchemaPart(resolvedSchema, path);\n    if (!schemaPart) throw new Error(\"Schema not found in path \\\"\" + path.join('.') + \"\\\"\");\n    // let x = schemaPart.x || {};\n    var result = {};\n    result.path = path;\n    if (path.length) result.name = path[path.length - 1];else result.version = 0; // this is root object\n    result.schema = resolvedSchema;\n    result.schemaPart = schemaPart;\n    result.schemaData = {\n        id: schemaPart.id,\n        title: schemaPart.title,\n        description: schemaPart.description,\n        type: schemaPart.type\n    };\n    result.status = {\n        touched: false,\n        reTouched: false,\n        pristine: true\n    };\n    result.messages = {};\n    result.funcs = {\n        parse: null,\n        format: null,\n        validators: null\n    };\n    result.params = {};\n    result.params.live = getValueFromParents(path, ['x', 'live'], resolvedSchema);\n    result.params.readonly = getValueFromParents(path, ['x', 'readonly'], resolvedSchema);\n    result.params.disabled = getValueFromParents(path, ['x', 'disabled'], resolvedSchema);\n    result.params.required = schemaPart.required;\n    if (schemaPart.type != 'object' && schemaPart.type != 'array') {\n        result.params.placeholder = schemaPart.x && schemaPart.x.placeholder;\n        result.params.autofocus = schemaPart.x && schemaPart.x.autofocus;\n        result.values = {\n            // current: getParentArrayValue(path, resolvedSchema) || schemaPart.default,\n            // inital: getParentArrayValue(path, resolvedSchema) || schemaPart.default,\n            'default': getParentArrayValue(path, resolvedSchema) || schemaPart.default\n        };\n    }\n    var valueMapArray = [];\n    // let schemaApi = getSchemaApi(resolvedSchema);\n    if (schemaPart.x && schemaPart.x.dataMap) {\n        schemaPart.x.dataMap.forEach(function (item) {\n            var from = item[0];\n            from = string2path(typeof from == 'function' ? from(resolvedSchema, utils, path) : from, path);\n            var to = item[1];\n            to = string2path(typeof to == 'function' ? to(resolvedSchema, utils, path) : to, path);\n            valueMapArray.push([from, to, item[2]]);\n        });\n    }\n    return { data: result, valueMap: mergeValueMapArray2Object(valueMapArray) };\n}\nfunction makeStateFromSchema(resolvedSchema) {\n    var currentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    var result = {};\n    var valueMapObjects = [];\n    var dataObj = makeDataObject(resolvedSchema, currentPath);\n    result[SymbolData] = dataObj.data;\n    valueMapObjects.push(dataObj.valueMap);\n    if (resolvedSchema.type == 'array') {\n        var vals = resolvedSchema.default;\n        var idx = 0;\n        if (vals && isArr(vals)) idx = vals.length;\n        if (resolvedSchema.minItems) idx = Math.max(idx, resolvedSchema.minItems);\n        for (var i = 0; i < idx; i++) {\n            var _dataObj = makeStateFromSchema(resolvedSchema, currentPath.concat(i));\n            valueMapObjects.push(_dataObj.valueMap);\n            result[i] = _dataObj.state;\n        }\n        result[SymbolData].length = idx;\n    } else {\n        objKeys(resolvedSchema.properties).forEach(function (field) {\n            if (resolvedSchema.properties) {\n                if (resolvedSchema.properties[field].type == 'object' || resolvedSchema.properties[field].type == 'array') {\n                    var _dataObj2 = makeStateFromSchema(resolvedSchema, currentPath.concat(field));\n                    valueMapObjects.push(_dataObj2.valueMap);\n                    result[field] = _dataObj2.state;\n                } else {\n                    result[field] = {};\n                    var _dataObj3 = makeDataObject(resolvedSchema.properties[field], currentPath.concat(field));\n                    valueMapObjects.push(_dataObj3.valueMap);\n                    result[field][SymbolData] = _dataObj3.data;\n                }\n            }\n        });\n    }\n    return { state: result, valueMap: mergeState({}, valueMapObjects) };\n}\nfunction makeKeyMapFromSchema(resolvedSchema) {\n    var path2start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    function mapPath2key(prefix, obj) {\n        var result = {};\n        objKeys(obj).forEach(function (val) {\n            if (typeof obj[val] == 'string') result[val] = prefix + obj[val];else result[val] = mapPath2key(prefix, obj[val]);\n        });\n        return result;\n    }\n    function recurse(resolvedSchema) {\n        var currentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n        var schemaPart = getSchemaPart(resolvedSchema, currentPath);\n        if (!schemaPart) return null;\n        var key2path = {},\n            path2key = {},\n            dataObj = {},\n            pKey = currentPath[currentPath.length - 1];\n        dataObj[SymbolData] = {};\n        if (schemaPart.type == \"object\") {\n            if (schemaPart.properties) {\n                objKeys(schemaPart.properties).forEach(function (key) {\n                    if (schemaPart && schemaPart.properties) {\n                        var _obj = schemaPart.properties[key];\n                        var objMap = void 0;\n                        if (_obj.type == 'object' || _obj.type == 'array') {\n                            (function () {\n                                objMap = recurse(resolvedSchema, currentPath.concat(key));\n                                var objMapData = objMap[SymbolData];\n                                if (objMapData.key2path && objKeys(objMapData.key2path).length) {\n                                    dataObj[key] = objMap;\n                                    if (_obj.x && _obj.x.flatten) {\n                                        (function () {\n                                            var prefix = _obj.x.flatten !== true && _obj.x.flatten || '';\n                                            objKeys(objMapData.key2path).forEach(function (key2) {\n                                                if (key2path.hasOwnProperty(prefix + key2)) throw new Error(\"Duplicate flatten name for \" + (prefix + key2));\n                                                key2path[prefix + key2] = [key].concat(objMapData.key2path[key2]);\n                                            });\n                                            path2key[key] = mapPath2key(prefix, objMapData.path2key);\n                                        })();\n                                    }\n                                }\n                            })();\n                        } else {\n                            key2path[key] = key;\n                            path2key[key] = key;\n                        }\n                    }\n                });\n            }\n        } else if (schemaPart.type == \"array\") {\n            var items = [];\n            var addable = false;\n            if (schemaPart.items) items = schemaPart.items;\n            if (!isArr(items)) items = [items];\n            if (schemaPart.additionalItems) {\n                addable = true;\n                if (schemaPart.additionalItems !== true) items.push(schemaPart.additionalItems);\n            } else addable = false;\n            for (var key = 0; key < items.length; key++) {\n                var _obj2 = items[key];\n                if (_obj2.type == 'object' || _obj2.type == 'array') dataObj[key] = recurse(resolvedSchema, currentPath.concat(key));\n            }\n            dataObj[SymbolData].isArray = true;\n            dataObj[SymbolData].addable = addable;\n            dataObj[SymbolData].length = items.length;\n        }\n        dataObj[SymbolData].key2path = key2path;\n        dataObj[SymbolData].path2key = path2key;\n        return dataObj;\n    }\n    function getMapData(obj, path) {\n        var result = obj;\n        for (var i = 0; i < path.length; i++) {\n            var key = path[i];\n            if (result[SymbolData].isArray) {\n                if (parseInt(key) < result[SymbolData].length) {\n                    result = result[key];\n                } else {\n                    if (result[SymbolData].addable) result = result[result[SymbolData].length - 1];else result = undefined;\n                }\n            } else result = result[key];\n            if (!result) return result;\n        }\n        return result;\n    }\n    var dataObj = recurse(resolvedSchema, path2start);\n    return {\n        key2path: function key2path(keyPath) {\n            if (typeof keyPath == 'string') keyPath = string2path(keyPath);\n            var result = [];\n            keyPath.forEach(function (key) {\n                var obj = getMapData(dataObj, result);\n                if (obj[SymbolData].key2path[key]) {\n                    result = result.concat(obj[SymbolData].key2path[key]);\n                } else result.push(key);\n            });\n            return result;\n        },\n        path2key: function path2key(path) {\n            var result = [];\n            var i = 0;\n            while (i < path.length) {\n                var key = path[i];\n                var _obj3 = getMapData(dataObj, path.slice(0, i));\n                var path2key = _obj3[SymbolData].path2key;\n                if (path2key) {\n                    var j = 0;\n                    while (1) {\n                        if (path2key[key]) {\n                            if (typeof path2key[key] == 'string') {\n                                key = path2key[key];\n                                i += j;\n                                break;\n                            } else {\n                                path2key = path2key[key];\n                                j++;\n                                key = path[i + j];\n                            }\n                        } else {\n                            key = path[i];\n                            break;\n                        }\n                    }\n                }\n                result.push(key);\n                i++;\n            }\n            return result;\n        }\n    };\n}\nexports.makeKeyMapFromSchema = makeKeyMapFromSchema;\n/////////////////////////////////////////////\n//      Utilities\n/////////////////////////////////////////////\nvar utils = {};\nutils.get = function (state, path) {\n    return getIn(state, string2path(path));\n};\nutils.isEqual = isEqual;\nutils.mergeState = mergeState;\nutils.string2path = string2path;\nutils.getSchemaPart = getSchemaPart;\nutils.makeDataObject = makeDataObject;\nfunction path2string(path, keyPath) {\n    return (keyPath ? path.concat('@', keyPath) : path).join('.');\n}\nfunction string2path(str, path) {\n    var res = str.split('.@.');\n    res[0] = res[0].split('.');\n    if (res[1]) res[1] = res[1].split('.');\n    if (path) res[0] = path.concat(res[0]);\n    return res;\n}\nfunction push2array(array) {\n    for (var _len = arguments.length, vals = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        vals[_key - 1] = arguments[_key];\n    }\n\n    array.push.apply(array, vals);\n    return array;\n}\nfunction object2PathValues(vals) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var track = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var fn = options.symbol ? objKeysAndSymbols : objKeys;\n    var check = options.arrayAsObject ? isMergeableObject : isObject;\n    var result = [];\n    fn(vals).forEach(function (key) {\n        var path = track.concat(key);\n        if (check(vals[key])) object2PathValues(vals[key], options, path).forEach(function (item) {\n            return result.push(item);\n        }); // result = result.concat(object2PathValues(vals[key], path));\n        else result.push(push2array(path, vals[key]));\n    });\n    if (!result.length) return [push2array(track.slice(), {})]; // empty object\n    return result;\n}\nexports.object2PathValues = object2PathValues;\nfunction moveArrayElems(arr, from, to) {\n    var length = arr.length;\n    from = (from % length + length) % length;\n    to = (to % length + length) % length;\n    var elem = arr[from];\n    if (from < to) for (var i = from; i < to; i++) {\n        arr[i] = arr[i + 1];\n    } else for (var _i2 = from; _i2 > to; _i2--) {\n        arr[_i2] = arr[_i2 - 1];\n    }arr[to] = elem;\n    return arr;\n}\nfunction resolveSchema(schema) {\n    var reference = schema['$ref'];\n    if (reference) {\n        if (!reference.match(/^#(\\/([a-zA-Z_][a-zA-Z_0-9]*|[0-9]+))*$/)) {\n            throw new Error('reference ' + reference + ' has unsupported format');\n        }\n        return mergeState(getIn(schema, reference.split('/').slice(1)), without(schema, false, '$ref')).state;\n    } else {\n        return schema;\n    }\n}\n;\nfunction makeSlice(pathValue) {\n    var track = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (pathValue.length == 0) return {};\n    if (pathValue.length == 1) return pathValue[0];\n    var keys = pathValue[0];\n    if (typeof keys === 'function') keys = keys(pathValue, track);\n    if (!isArr(keys)) keys = [keys];\n    var result = {};\n    keys.forEach(function (key) {\n        result[key] = makeSlice(pathValue.slice(1), track.concat(key));\n    });\n    return result;\n}\nexports.makeSlice = makeSlice;\nfunction getIn(store, path) {\n    if (path.length == 0 || store == undefined) return store;else if (typeof path[0] === 'function') return getIn(store[path[0](store)], path.slice(1));\n    return getIn(store[path[0]], path.slice(1));\n}\nexports.getIn = getIn;\n;\nfunction getSlice(store, path) {\n    var track = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    return makeSlice(path.concat(getIn(store, path)));\n}\nfunction without(obj) {\n    for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        rest[_key2 - 2] = arguments[_key2];\n    }\n\n    var symbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    //const args = arrFrom(rest); // [].slice.call(arguments);\n    var result = isArr(obj) ? [] : {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).forEach(function (key) {\n        if (!~rest.indexOf(key)) result[key] = obj[key];\n    });\n    return result;\n}\n;\nfunction split(test, obj) {\n    var symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var passed = {};\n    var wrong = {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).forEach(function (key) {\n        var val = obj[key];\n        if (test(key, val)) passed[key] = val;else wrong[key] = val;\n    });\n    return [passed, wrong];\n}\n;\nfunction map(fnc, obj) {\n    var symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var result = {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).forEach(function (key) {\n        return result[key] = fnc(obj[key]);\n    });\n    return result;\n}\n;\nfunction mapKeys(fnc, obj) {\n    var symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var result = {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).map(function (key) {\n        return result[fnc(key)] = obj[key];\n    });\n    return result;\n}\n;\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\nfunction is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n        // Steps 6.b-6.e: +0 != -0\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        // Step 6.a: NaN == NaN\n        return x !== x && y !== y;\n    }\n}\nfunction isEqual(objA, objB) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (is(objA, objB)) return true;\n    if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) return false;\n    var fn = options.symbol ? objKeysAndSymbols : objKeys;\n    var keysA = fn(objA);\n    var keysB = fn(objB);\n    if (keysA.length !== keysB.length) return false;\n    var _options$skipKeys = options.skipKeys,\n        skipKeys = _options$skipKeys === undefined ? [] : _options$skipKeys,\n        _options$deepKeys = options.deepKeys,\n        deepKeys = _options$deepKeys === undefined ? [] : _options$deepKeys;\n\n    for (var i = 0; i < keysA.length; i++) {\n        if (~skipKeys.indexOf(keysA[i])) continue; // if key is an skip key, skip comparison\n        if (options.deep || ~deepKeys.indexOf(keysA[i])) {\n            var result = isEqual(objA[keysA[i]], objB[keysA[i]], options);\n            if (!result) return false;\n        } else if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isEqual = isEqual;\n// returns {state, changes} where state is new object only if changes were made, otherwise return {state} where state is passed state\nfunction mergeState(state, obj) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var result = {};\n    var changes = {};\n    var fn = options.symbol ? objKeysAndSymbols : objKeys;\n    if (!isObject(state)) state = {}; // return only objects\n    if (isArr(obj)) {\n        if (obj.length == 0) return { state: state }; // no changes should be done\n        else if (obj.length == 1) obj = obj[0];else obj = obj.reduce(function (prev, next) {\n                return mergeState(prev, next, { symbol: options.symbol }).state;\n            }); // merge without clear\n    }\n    if (!isObject(obj)) return { state: state }; // merge only objects, may be make here throw\n    var _options$skipKeys2 = options.skipKeys,\n        skipKeys = _options$skipKeys2 === undefined ? [] : _options$skipKeys2;\n\n    fn(state).forEach(function (key) {\n        if (!~skipKeys.indexOf(key)) result[key] = state[key];\n    });\n    fn(obj).forEach(function (key) {\n        if (!~skipKeys.indexOf(key)) {\n            if (!isObject(obj[key])) {\n                if (options.clear && obj[key] === SymbolDelete) {\n                    if (state.hasOwnProperty(key)) changes[key] = obj[key];\n                    if (result.hasOwnProperty(key)) delete result[key];\n                } else {\n                    if (!is(state[key], obj[key]) || !state.hasOwnProperty(key)) changes[key] = obj[key];\n                    result[key] = obj[key];\n                }\n            } else {\n                var tmp = mergeState(state[key], obj[key], options);\n                if (options.clear && fn(tmp.state).length == 0) {\n                    if (state.hasOwnProperty(key)) changes[key] = SymbolDelete;\n                    if (result.hasOwnProperty(key)) delete result[key];\n                } else {\n                    if (tmp.changes) changes[key] = tmp.changes;\n                    result[key] = tmp.state;\n                }\n            }\n        }\n    });\n    if (fn(changes).length == 0) return { state: state };else return { state: result, changes: changes };\n}\nexports.mergeState = mergeState;\nfunction isObject(val) {\n    return isMergeableObject(val) && !isArr(val);\n}\nfunction isMergeableObject(val) {\n    var nonNullObject = val && (typeof val === \"undefined\" ? \"undefined\" : _typeof2(val)) === 'object';\n    return nonNullObject && Object.prototype.toString.call(val) !== '[object RegExp]' && Object.prototype.toString.call(val) !== '[object Date]';\n}\n// export function makeSlice(path: PathSlice, value: any, track: PathSlice = []): StateType {\n//   if (path.length == 0) return value;\n//   let keys: any = path[0];\n//   if (typeof keys === 'function') keys = keys(path, track);\n//   if (!isArr(keys)) keys = [keys];\n//   let result = {};\n//   keys.forEach((key: string | number) => {\n//     let newTrack = track.slice();\n//     newTrack.push(key);\n//     result[key] = makeSlice(path.slice(1), value, newTrack)\n//   });\n//   return result;\n// }\n// export function getSlice(store: any, path: PathSlice, track: PathSlice = []): {} {\n//   if (path.length == 0 || store == undefined)\n//     return store;\n//   else {\n//     let keys: any = path[0];\n//     if (typeof keys === 'function') keys = keys(store, path, track);\n//     if (!isArr(keys)) keys = [keys];\n//     let result = {};\n//     keys.forEach((key: string | number) => {\n//       let newTrack = track.slice();\n//       newTrack.push(key);\n//       result[key] = getSlice(store[key], path.slice(1), newTrack)\n//     });\n//     return result;\n//   }\n// };\n//\n// export function setIn(store: {}, path: Path, value: any) {\n//   if (path.length == 0)\n//     return value;\n//   else {\n//     let child = (store == null) ? null : store[path[0]];\n//     value = setIn(child || [], path.slice(1), value);\n//     return mergeState(store, object(path[0], value)).state;\n//   }\n// };\n//\n//\n// export function setSlice(store: any, ...rest: any[]): SetSliceResultType {\n//   let changes = [];\n//   for (let i = 0; i + 1 < rest.length; i += 2) {\n//     let path = rest[i], value = rest[i + 1];\n//     if (!isEqual(getIn(store, path), value, {deep: true, symbol: true, onlyKeysB: true}))\n//       changes.push(makeSlice(value, path));\n//   }\n//   if (changes.length == 0) return {data: store};\n//   if (changes.length > 1) changes = merge.all(changes); else changes = changes[0];\n//   return {data: merge(store, changes), changes}\n// }\n//\n// function object(...args: any[]) {\n//   // const args = arrFrom(arguments);\n//   let result: any = [];\n//   for (let i = 0; i + 1 < args.length; i += 2) {\n//     let x = args[i];\n//     if (typeof x != 'number' || x < 0 || x % 1 != 0) result = {};\n//   }\n//   for (let i = 0; i + 1 < args.length; i += 2) result[args[i]] = args[i + 1];\n//   return result;\n// };\n// function flatten(data: any, symbol = false) {\n//   const result = {};\n//   const delimiter = '.';\n//   const fn = symbol ? objKeys : objKeysAndSymbols;\n//\n//   function recurse(cur: any, prop = '') {\n//     if (Object(cur) !== cur) {\n//       result[prop] = cur;\n//     } else if (isArr(cur)) {\n//       if (!cur.length) result[prop] = [];\n//\n//       cur.forEach((item, i) => {\n//         recurse(cur[i], prop\n//           ? [prop, i].join(delimiter)\n//           : `${i}`);\n//       });\n//     } else {\n//       let isEmpty = true;\n//\n//       fn(cur).forEach((key) => {\n//         isEmpty = false;\n//         recurse(cur[key], prop\n//           ? [prop, key].join(delimiter)\n//           : key);\n//       });\n//\n//       if (isEmpty) result[prop] = {};\n//     }\n//   }\n//   recurse(data);\n//   return result;\n// }\n//\n// function clear(state: any, symbol = false) { // remove undefined values and empty objects or arrays\n//   let result: any, isArray: boolean;\n//   if (state === undefined) result = undefined;\n//   else if (isArr(state) || isObject(state)) {\n//     isArray = isArr(state);\n//     result = isArray ? [] : {};\n//     const fn = symbol ? objKeys : objKeysAndSymbols;\n//     fn(state).forEach(key => {\n//       let val = clear(state[key]);\n//       if (val !== undefined) {\n//         if (isArray) result.push(val); else result[key] = val;\n//       }\n//     });\n//     if (fn(result).length == 0) result = undefined;\n//   } else result = state;\n//   return result;\n// };\n//\n// function getDiffForSecondObject(objA: any, objB: any, symbol = false) {\n//   const fn = symbol ? objKeysAndSymbols : objKeys;\n//   const result = {};\n//   fn(objB).forEach((key) => {\n//     if (isObject(objB)) {\n//       if (isObject(objA)) result[key] = getDiffForSecondObject(objA[key], objB[key], symbol);\n//       else result[key] = objB[key];\n//     } else {\n//       if (objB[key] != objA[key]) result[key] = objB[key];\n//     }\n//   });\n//   return result;\n// }\n/*\r\n /////////////////////////////////////////////\r\n // https://github.com/KyleAMathews/deepmerge, modified to merge Symbols\r\n /////////////////////////////////////////////\r\n\r\n\r\n const merge: any = function () {\r\n\r\n function emptyTarget(val: any) {\r\n return isArr(val) ? [] : {}\r\n }\r\n\r\n function cloneIfNecessary(value: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const clone = optionsArgument && optionsArgument.clone === true;\r\n return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value\r\n }\r\n\r\n function defaultArrayMerge(target: any, source: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const destination = target.slice();\r\n source.forEach(function (e: any, i: any) {\r\n if (typeof destination[i] === 'undefined') {\r\n destination[i] = cloneIfNecessary(e, optionsArgument)\r\n } else if (isMergeableObject(e)) {\r\n destination[i] = deepmerge(target[i], e, optionsArgument)\r\n } else if (target.indexOf(e) === -1) {\r\n destination.push(cloneIfNecessary(e, optionsArgument))\r\n }\r\n });\r\n return destination\r\n }\r\n\r\n function mergeObject(target: any, source: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const destination = {};\r\n let fn = (optionsArgument && optionsArgument.symbol) ? objKeysAndSymbols : objKeys;\r\n if (isMergeableObject(target)) {\r\n fn(target).forEach(function (key) {\r\n destination[key] = cloneIfNecessary(target[key], optionsArgument)\r\n })\r\n }\r\n fn(source).forEach(function (key) {\r\n if (!isMergeableObject(source[key]) || !target[key]) {\r\n destination[key] = cloneIfNecessary(source[key], optionsArgument)\r\n } else {\r\n destination[key] = deepmerge(target[key], source[key], optionsArgument)\r\n }\r\n });\r\n return destination\r\n }\r\n\r\n const deepmerge: any = function (target: any, source: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const array = isArr(source);\r\n const options = optionsArgument || {arrayMerge: defaultArrayMerge};\r\n const arrayMerge = options.arrayMerge || defaultArrayMerge;\r\n\r\n if (array) {\r\n return isArr(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)\r\n } else {\r\n return mergeObject(target, source, optionsArgument)\r\n }\r\n };\r\n\r\n deepmerge.all = function deepmergeAll(array: any[], optionsArgument?: DeepmergeOptionsArgument) {\r\n if (array.length < 2) throw new Error('Should be at least two elements');\r\n\r\n // we are sure there are at least 2 values, so it is safe to have no initial value\r\n return array.reduce(function (prev, next) {\r\n return deepmerge(prev, next, optionsArgument)\r\n })\r\n };\r\n\r\n return deepmerge\r\n\r\n }();*/"
        }
      ],
      "filteredModules": 0,
      "origins": [
        {
          "moduleId": 7,
          "module": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "moduleName": "./src/core.tsx",
          "loc": "",
          "name": "app",
          "reasons": []
        }
      ]
    }
  ],
  "modules": [
    {
      "id": 0,
      "identifier": "external \"react\"",
      "name": "external \"react\"",
      "index": 1,
      "index2": 0,
      "size": 42,
      "cacheable": false,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
      "issuerId": 7,
      "issuerName": "./src/core.tsx",
      "profile": {
        "factory": 0,
        "building": 0
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "module": "./src/core.tsx",
          "moduleName": "./src/core.tsx",
          "type": "cjs require",
          "userRequest": "react",
          "loc": "30:12-28"
        },
        {
          "moduleId": 7,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "module": "./src/core.tsx",
          "moduleName": "./src/core.tsx",
          "type": "cjs require",
          "userRequest": "react",
          "loc": "31:14-30"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 1
    },
    {
      "id": 1,
      "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
      "name": "./~/is-my-json-valid/index.js",
      "index": 2,
      "index2": 6,
      "size": 16936,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
      "issuerId": 7,
      "issuerName": "./src/core.tsx",
      "profile": {
        "factory": 10,
        "building": 40
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
          "module": "./src/core.tsx",
          "moduleName": "./src/core.tsx",
          "type": "cjs require",
          "userRequest": "is-my-json-valid",
          "loc": "42:16-43"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 1,
      "source": "var genobj = require('generate-object-property')\nvar genfun = require('generate-function')\nvar jsonpointer = require('jsonpointer')\nvar xtend = require('xtend')\nvar formats = require('./formats')\n\nvar get = function(obj, additionalSchemas, ptr) {\n\n  var visit = function(sub) {\n    if (sub && sub.id === ptr) return sub\n    if (typeof sub !== 'object' || !sub) return null\n    return Object.keys(sub).reduce(function(res, k) {\n      return res || visit(sub[k])\n    }, null)\n  }\n\n  var res = visit(obj)\n  if (res) return res\n\n  ptr = ptr.replace(/^#/, '')\n  ptr = ptr.replace(/\\/$/, '')\n\n  try {\n    return jsonpointer.get(obj, decodeURI(ptr))\n  } catch (err) {\n    var end = ptr.indexOf('#')\n    var other\n    // external reference\n    if (end !== 0) {\n      // fragment doesn't exist.\n      if (end === -1) {\n        other = additionalSchemas[ptr]\n      } else {\n        var ext = ptr.slice(0, end)\n        other = additionalSchemas[ext]\n        var fragment = ptr.slice(end).replace(/^#/, '')\n        try {\n          return jsonpointer.get(other, fragment)\n        } catch (err) {}\n      }\n    } else {\n      other = additionalSchemas[ptr]\n    }\n    return other || null\n  }\n}\n\nvar formatName = function(field) {\n  field = JSON.stringify(field)\n  var pattern = /\\[([^\\[\\]\"]+)\\]/\n  while (pattern.test(field)) field = field.replace(pattern, '.\"+$1+\"')\n  return field\n}\n\nvar types = {}\n\ntypes.any = function() {\n  return 'true'\n}\n\ntypes.null = function(name) {\n  return name+' === null'\n}\n\ntypes.boolean = function(name) {\n  return 'typeof '+name+' === \"boolean\"'\n}\n\ntypes.array = function(name) {\n  return 'Array.isArray('+name+')'\n}\n\ntypes.object = function(name) {\n  return 'typeof '+name+' === \"object\" && '+name+' && !Array.isArray('+name+')'\n}\n\ntypes.number = function(name) {\n  return 'typeof '+name+' === \"number\"'\n}\n\ntypes.integer = function(name) {\n  return 'typeof '+name+' === \"number\" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'\n}\n\ntypes.string = function(name) {\n  return 'typeof '+name+' === \"string\"'\n}\n\nvar unique = function(array) {\n  var list = []\n  for (var i = 0; i < array.length; i++) {\n    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])\n  }\n  for (var i = 1; i < list.length; i++) {\n    if (list.indexOf(list[i]) !== i) return false\n  }\n  return true\n}\n\nvar isMultipleOf = function(name, multipleOf) {\n  var res;\n  var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1\n  if (factor > 1) {\n    var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1\n    if (factorName > factor) res = true\n    else res = Math.round(factor * name) % (factor * multipleOf)\n  }\n  else res = name % multipleOf;\n  return !res;\n}\n\nvar toType = function(node) {\n  return node.type\n}\n\nvar compile = function(schema, cache, root, reporter, opts) {\n  var fmts = opts ? xtend(formats, opts.formats) : formats\n  var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf}\n  var verbose = opts ? !!opts.verbose : false;\n  var greedy = opts && opts.greedy !== undefined ?\n    opts.greedy : false;\n\n  var syms = {}\n  var gensym = function(name) {\n    return name+(syms[name] = (syms[name] || 0)+1)\n  }\n\n  var reversePatterns = {}\n  var patterns = function(p) {\n    if (reversePatterns[p]) return reversePatterns[p]\n    var n = gensym('pattern')\n    scope[n] = new RegExp(p)\n    reversePatterns[p] = n\n    return n\n  }\n\n  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']\n  var genloop = function() {\n    var v = vars.shift()\n    vars.push(v+v[0])\n    return v\n  }\n\n  var visit = function(name, node, reporter, filter) {\n    var properties = node.properties\n    var type = node.type\n    var tuple = false\n\n    if (Array.isArray(node.items)) { // tuple type\n      properties = {}\n      node.items.forEach(function(item, i) {\n        properties[i] = item\n      })\n      type = 'array'\n      tuple = true\n    }\n\n    var indent = 0\n    var error = function(msg, prop, value) {\n      validate('errors++')\n      if (reporter === true) {\n        validate('if (validate.errors === null) validate.errors = []')\n        if (verbose) {\n          validate('validate.errors.push({field:%s,message:%s,value:%s,type:%s})', formatName(prop || name), JSON.stringify(msg), value || name, JSON.stringify(type))\n        } else {\n          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))\n        }\n      }\n    }\n\n    if (node.required === true) {\n      indent++\n      validate('if (%s === undefined) {', name)\n      error('is required')\n      validate('} else {')\n    } else {\n      indent++\n      validate('if (%s !== undefined) {', name)\n    }\n\n    var valid = [].concat(type)\n      .map(function(t) {\n        return types[t || 'any'](name)\n      })\n      .join(' || ') || 'true'\n\n    if (valid !== 'true') {\n      indent++\n      validate('if (!(%s)) {', valid)\n      error('is the wrong type')\n      validate('} else {')\n    }\n\n    if (tuple) {\n      if (node.additionalItems === false) {\n        validate('if (%s.length > %d) {', name, node.items.length)\n        error('has additional items')\n        validate('}')\n      } else if (node.additionalItems) {\n        var i = genloop()\n        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)\n        visit(name+'['+i+']', node.additionalItems, reporter, filter)\n        validate('}')\n      }\n    }\n\n    if (node.format && fmts[node.format]) {\n      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))\n      var n = gensym('format')\n      scope[n] = fmts[node.format]\n\n      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)\n      else validate('if (!%s.test(%s)) {', n, name)\n      error('must be '+node.format+' format')\n      validate('}')\n      if (type !== 'string' && formats[node.format]) validate('}')\n    }\n\n    if (Array.isArray(node.required)) {\n      var isUndefined = function(req) {\n        return genobj(name, req) + ' === undefined'\n      }\n\n      var checkRequired = function (req) {\n        var prop = genobj(name, req);\n        validate('if (%s === undefined) {', prop)\n        error('is required', prop)\n        validate('missing++')\n        validate('}')\n      }\n      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')\n      validate('var missing = 0')\n      node.required.map(checkRequired)\n      validate('}');\n      if (!greedy) {\n        validate('if (missing === 0) {')\n        indent++\n      }\n    }\n\n    if (node.uniqueItems) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n      validate('if (!(unique(%s))) {', name)\n      error('must be unique')\n      validate('}')\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.enum) {\n      var complex = node.enum.some(function(e) {\n        return typeof e === 'object'\n      })\n\n      var compare = complex ?\n        function(e) {\n          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'\n        } :\n        function(e) {\n          return name+' !== '+JSON.stringify(e)\n        }\n\n      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')\n      error('must be an enum value')\n      validate('}')\n    }\n\n    if (node.dependencies) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      Object.keys(node.dependencies).forEach(function(key) {\n        var deps = node.dependencies[key]\n        if (typeof deps === 'string') deps = [deps]\n\n        var exists = function(k) {\n          return genobj(name, k) + ' !== undefined'\n        }\n\n        if (Array.isArray(deps)) {\n          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')\n          error('dependencies not set')\n          validate('}')\n        }\n        if (typeof deps === 'object') {\n          validate('if (%s !== undefined) {', genobj(name, key))\n          visit(name, deps, reporter, filter)\n          validate('}')\n        }\n      })\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.additionalProperties || node.additionalProperties === false) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      var i = genloop()\n      var keys = gensym('keys')\n\n      var toCompare = function(p) {\n        return keys+'['+i+'] !== '+JSON.stringify(p)\n      }\n\n      var toTest = function(p) {\n        return '!'+patterns(p)+'.test('+keys+'['+i+'])'\n      }\n\n      var additionalProp = Object.keys(properties || {}).map(toCompare)\n        .concat(Object.keys(node.patternProperties || {}).map(toTest))\n        .join(' && ') || 'true'\n\n      validate('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n          ('if (%s) {', additionalProp)\n\n      if (node.additionalProperties === false) {\n        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')\n        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')\n      } else {\n        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)\n      }\n\n      validate\n          ('}')\n        ('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.$ref) {\n      var sub = get(root, opts && opts.schemas || {}, node.$ref)\n      if (sub) {\n        var fn = cache[node.$ref]\n        if (!fn) {\n          cache[node.$ref] = function proxy(data) {\n            return fn(data)\n          }\n          fn = compile(sub, cache, root, false, opts)\n        }\n        var n = gensym('ref')\n        scope[n] = fn\n        validate('if (!(%s(%s))) {', n, name)\n        error('referenced schema does not match')\n        validate('}')\n      }\n    }\n\n    if (node.not) {\n      var prev = gensym('prev')\n      validate('var %s = errors', prev)\n      visit(name, node.not, false, filter)\n      validate('if (%s === errors) {', prev)\n      error('negative schema matches')\n      validate('} else {')\n        ('errors = %s', prev)\n      ('}')\n    }\n\n    if (node.items && !tuple) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      var i = genloop()\n      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)\n      visit(name+'['+i+']', node.items, reporter, filter)\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.patternProperties) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n      var keys = gensym('keys')\n      var i = genloop()\n      validate\n        ('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n\n      Object.keys(node.patternProperties).forEach(function(key) {\n        var p = patterns(key)\n        validate('if (%s.test(%s)) {', p, keys+'['+i+']')\n        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)\n        validate('}')\n      })\n\n      validate('}')\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.pattern) {\n      var p = patterns(node.pattern)\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n      validate('if (!(%s.test(%s))) {', p, name)\n      error('pattern mismatch')\n      validate('}')\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.allOf) {\n      node.allOf.forEach(function(sch) {\n        visit(name, sch, reporter, filter)\n      })\n    }\n\n    if (node.anyOf && node.anyOf.length) {\n      var prev = gensym('prev')\n\n      node.anyOf.forEach(function(sch, i) {\n        if (i === 0) {\n          validate('var %s = errors', prev)\n        } else {\n          validate('if (errors !== %s) {', prev)\n            ('errors = %s', prev)\n        }\n        visit(name, sch, false, false)\n      })\n      node.anyOf.forEach(function(sch, i) {\n        if (i) validate('}')\n      })\n      validate('if (%s !== errors) {', prev)\n      error('no schemas match')\n      validate('}')\n    }\n\n    if (node.oneOf && node.oneOf.length) {\n      var prev = gensym('prev')\n      var passes = gensym('passes')\n\n      validate\n        ('var %s = errors', prev)\n        ('var %s = 0', passes)\n\n      node.oneOf.forEach(function(sch, i) {\n        visit(name, sch, false, false)\n        validate('if (%s === errors) {', prev)\n          ('%s++', passes)\n        ('} else {')\n          ('errors = %s', prev)\n        ('}')\n      })\n\n      validate('if (%s !== 1) {', passes)\n      error('no (or more than one) schemas match')\n      validate('}')\n    }\n\n    if (node.multipleOf !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)\n\n      error('has a remainder')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maxProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)\n      error('has more properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.minProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)\n      error('has less properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.maxItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length > %d) {', name, node.maxItems)\n      error('has more items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.minItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length < %d) {', name, node.minItems)\n      error('has less items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.maxLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length > %d) {', name, node.maxLength)\n      error('has longer length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length < %d) {', name, node.minLength)\n      error('has less length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minimum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)\n      error('is less than minimum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maximum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)\n      error('is more than maximum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (properties) {\n      Object.keys(properties).forEach(function(p) {\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)\n\n        visit(genobj(name, p), properties[p], reporter, filter)\n\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')\n      })\n    }\n\n    while (indent--) validate('}')\n  }\n\n  var validate = genfun\n    ('function validate(data) {')\n      // Since undefined is not a valid JSON value, we coerce to null and other checks will catch this\n      ('if (data === undefined) data = null')\n      ('validate.errors = null')\n      ('var errors = 0')\n\n  visit('data', schema, reporter, opts && opts.filter)\n\n  validate\n      ('return errors === 0')\n    ('}')\n\n  validate = validate.toFunction(scope)\n  validate.errors = null\n\n  if (Object.defineProperty) {\n    Object.defineProperty(validate, 'error', {\n      get: function() {\n        if (!validate.errors) return ''\n        return validate.errors.map(function(err) {\n          return err.field + ' ' + err.message;\n        }).join('\\n')\n      }\n    })\n  }\n\n  validate.toJSON = function() {\n    return schema\n  }\n\n  return validate\n}\n\nmodule.exports = function(schema, opts) {\n  if (typeof schema === 'string') schema = JSON.parse(schema)\n  return compile(schema, {}, schema, true, opts)\n}\n\nmodule.exports.filter = function(schema, opts) {\n  var validate = module.exports(schema, xtend(opts, {filter: true}))\n  return function(sch) {\n    validate(sch)\n    return sch\n  }\n}\n"
    },
    {
      "id": 2,
      "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\generate-function\\index.js",
      "name": "./~/generate-function/index.js",
      "index": 4,
      "index2": 2,
      "size": 1180,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
      "issuerId": 1,
      "issuerName": "./~/is-my-json-valid/index.js",
      "profile": {
        "factory": 20,
        "building": 10
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "module": "./~/is-my-json-valid/index.js",
          "moduleName": "./~/is-my-json-valid/index.js",
          "type": "cjs require",
          "userRequest": "generate-function",
          "loc": "2:13-41"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "var INDENT_START = /[\\{\\[]/\nvar INDENT_END = /[\\}\\]]/\n\nmodule.exports = function() {\n  var lines = []\n  var indent = 0\n\n  var push = function(str) {\n    var spaces = ''\n    while (spaces.length < indent*2) spaces += '  '\n    lines.push(spaces+str)\n  }\n\n  var line = function(fmt) {\n    if (!fmt) return line\n\n    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {\n      indent--\n      push(arguments[0])\n      indent++\n      return line\n    }\n    if (INDENT_START.test(fmt[fmt.length-1])) {\n      push(arguments[0])\n      indent++\n      return line\n    }\n    if (INDENT_END.test(fmt.trim()[0])) {\n      indent--\n      push(arguments[0])\n      return line\n    }\n\n    push(arguments[0])\n    return line\n  }\n\n  line.toString = function() {\n    return lines.join('\\n')\n  }\n\n  line.toFunction = function(scope) {\n    var src = 'return ('+line.toString()+')'\n\n    var keys = Object.keys(scope || {}).map(function(key) {\n      return key\n    })\n\n    var vals = keys.map(function(key) {\n      return scope[key]\n    })\n\n    return Function.apply(null, keys.concat(src)).apply(null, vals)\n  }\n\n  if (arguments.length) line.apply(null, arguments)\n\n  return line\n}\n"
    },
    {
      "id": 3,
      "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\generate-object-property\\index.js",
      "name": "./~/generate-object-property/index.js",
      "index": 3,
      "index2": 1,
      "size": 290,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
      "issuerId": 1,
      "issuerName": "./~/is-my-json-valid/index.js",
      "profile": {
        "factory": 20,
        "building": 0
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "module": "./~/is-my-json-valid/index.js",
          "moduleName": "./~/is-my-json-valid/index.js",
          "type": "cjs require",
          "userRequest": "generate-object-property",
          "loc": "1:13-48"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "var isProperty = function(){return false};\n\nvar gen = function(obj, prop) {\n  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'\n}\n\ngen.valid = isProperty\ngen.property = function (prop) {\n return isProperty(prop) ? prop : JSON.stringify(prop)\n}\n\nmodule.exports = gen\n"
    },
    {
      "id": 4,
      "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\formats.js",
      "name": "./~/is-my-json-valid/formats.js",
      "index": 7,
      "index2": 5,
      "size": 2349,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
      "issuerId": 1,
      "issuerName": "./~/is-my-json-valid/index.js",
      "profile": {
        "factory": 0,
        "building": 10
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "module": "./~/is-my-json-valid/index.js",
          "moduleName": "./~/is-my-json-valid/index.js",
          "type": "cjs require",
          "userRequest": "./formats",
          "loc": "5:14-34"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "exports['date-time'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?([zZ]|[+-]\\d{2}:\\d{2})$/\nexports['date'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/\nexports['time'] = /^\\d{2}:\\d{2}:\\d{2}$/\nexports['email'] = /^\\S+@\\S+$/\nexports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/\nexports['ipv6'] = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/\nexports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/\nexports['color'] = /(#?([0-9A-Fa-f]{3,6})\\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\))/\nexports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$/\nexports['alpha'] = /^[a-zA-Z]+$/\nexports['alphanumeric'] = /^[a-zA-Z0-9]+$/\nexports['style'] = /\\s*(.+?):\\s*([^;]+);?/g\nexports['phone'] = /^\\+(?:[0-9] ?){6,14}[0-9]$/\nexports['utc-millisec'] = /^[0-9]{1,15}\\.?[0-9]{0,15}$/\n"
    },
    {
      "id": 5,
      "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\jsonpointer\\jsonpointer.js",
      "name": "./~/jsonpointer/jsonpointer.js",
      "index": 5,
      "index2": 3,
      "size": 2268,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
      "issuerId": 1,
      "issuerName": "./~/is-my-json-valid/index.js",
      "profile": {
        "factory": 20,
        "building": 10
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "module": "./~/is-my-json-valid/index.js",
          "moduleName": "./~/is-my-json-valid/index.js",
          "type": "cjs require",
          "userRequest": "jsonpointer",
          "loc": "3:18-40"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "var hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object') return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n"
    },
    {
      "id": 6,
      "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\xtend\\immutable.js",
      "name": "./~/xtend/immutable.js",
      "index": 6,
      "index2": 4,
      "size": 384,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
      "issuerId": 1,
      "issuerName": "./~/is-my-json-valid/index.js",
      "profile": {
        "factory": 20,
        "building": 10
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\is-my-json-valid\\index.js",
          "module": "./~/is-my-json-valid/index.js",
          "moduleName": "./~/is-my-json-valid/index.js",
          "type": "cjs require",
          "userRequest": "xtend",
          "loc": "4:12-28"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n"
    },
    {
      "id": 7,
      "identifier": "C:\\workspace\\nodejs\\FForm\\node_modules\\babel-loader\\lib\\index.js!C:\\workspace\\nodejs\\FForm\\node_modules\\ts-loader\\index.js!C:\\workspace\\nodejs\\FForm\\src\\core.tsx",
      "name": "./src/core.tsx",
      "index": 0,
      "index2": 7,
      "size": 69330,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": null,
      "issuerId": null,
      "issuerName": null,
      "profile": {
        "factory": 20,
        "building": 3430
      },
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [],
      "usedExports": true,
      "providedExports": null,
      "depth": 0,
      "source": "\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) {\n            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n    }\n    return t;\n};\nvar __rest = this && this.__rest || function (s, e) {\n    var t = {};\n    for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n        if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n    }return t;\n};\nvar React = require(\"react\");\nvar react_1 = require(\"react\");\nvar objKeys = Object.keys; // getOwnPropertyNames\nvar isArr = Array.isArray;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar SymbolData = Symbol.for('FFormData');\nvar SymbolRecalc = Symbol.for('FFormRecalc');\nvar SymbolArray = Symbol.for('FFormArray');\nvar SymbolMap = Symbol.for('FFormMap');\nvar SymbolDelete = Symbol.for('FFormDelete');\nvar formReducerValue = 'forms';\n//const SymbolFor = Symbol.for;\nvar validator = require('is-my-json-valid');\nfunction objKeysAndSymbols(obj) {\n    var result = objKeys(obj);\n    return result.concat(Object.getOwnPropertySymbols(obj));\n}\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        return objKeys(baseCtor.prototype).forEach(function (name) {\n            return derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n/////////////////////////////////////////////\n//  Hooks\n/////////////////////////////////////////////\nfunction hookManager() {\n    var globalHooks = {};\n    var Hooks = {};\n    function setHook(name, hookName, hook) {\n        if (!Hooks[name]) Hooks[name] = {};\n        if (!Hooks[name][hookName]) Hooks[name][hookName] = globalHooks[hookName].slice();\n        Hooks[name][hookName].push(hook);\n    }\n    var add = function add(name, hookName, hook) {\n        if (name == '') {\n            if (!globalHooks[hookName]) globalHooks[hookName] = [];\n            objKeys(Hooks).forEach(function (key) {\n                return setHook(key, hookName, hook);\n            });\n            globalHooks[hookName].push(hook);\n        } else setHook(name, hookName, hook);\n        return remove.bind(null, name, hookName, hook);\n    };\n    function remove(name, hookName, hook) {\n        if (name == '') {\n            globalHooks[hookName].splice(globalHooks[hookName].indexOf(hook), 1);\n            objKeys(Hooks).forEach(function (key) {\n                return Hooks[key][hookName].splice(Hooks[key][hookName].indexOf(hook));\n            }, 1);\n        } else Hooks[name][hookName].splice(Hooks[name][hookName].indexOf(hook), 1);\n    }\n    ;\n    // add.remove = remove;\n    add.get = function (name) {\n        return Hooks[name];\n    };\n    return add;\n}\nvar Hooks = hookManager();\nexports.addHook = Hooks;\n// update children\nHooks('', 'beforeMerge', function (item, state, data, utils) {\n    var res = { result: true };\n    if (item[1][0] == 'paramSwitcher' && item[1].length == 2) {\n        res.result = false;\n        res.changes = object2PathValues(getIn(state, item[0])).map(function (pathValue) {\n            pathValue.pop();\n            var keyPath = item[1].slice();\n            keyPath[0] = 'param';\n            return [pathValue, keyPath, item[2]];\n        });\n    }\n    return res;\n});\n// recalc array\nHooks('', 'beforeMerge', function (item, state, data, utils) {\n    if (item[1][0] == 'length') {\n        if (!data[SymbolArray]) data[SymbolArray] = {};\n        data[SymbolArray][path2string(item[0])] = { path: item[0] };\n    }\n    return true;\n});\n// set data for parent\nHooks('', 'beforeMerge', function (item, state, data, utils) {\n    var result = true;\n    var changes = [];\n    // if(!data[SymbolRecalc]) data[SymbolRecalc] = {};\n    if (item[1][0] == 'status' && item[1].length == 2) {\n        var param = item[1][1];\n        var checkValue = param == 'valid' || param == 'pristine'; // true for valid and pristine\n        // if(getIn(state, item[0].concat(SymbolData).concat(item[1])))\n        var checkItem = item[2] == checkValue ? SymbolRecalc : item[2];\n        var path = item[0].slice();\n        for (var i = 0; i < item[0].length; i++) {\n            path.pop();\n            changes.push([path, item[1], checkItem]);\n            if ((typeof checkItem === \"undefined\" ? \"undefined\" : _typeof2(checkItem)) == 'symbol') {\n                if (!data[SymbolRecalc]) data[SymbolRecalc] = {};\n                if (!data[SymbolRecalc][path.length]) data[SymbolRecalc][path.length] = {};\n                if (!data[SymbolRecalc].length || data[SymbolRecalc].length < path.length) data[SymbolRecalc].length = path.length;\n                data[SymbolRecalc][path.length][path2string(path, item[1])] = {\n                    path: path,\n                    keyPath: item[1],\n                    checkValue: checkValue\n                };\n            }\n        }\n    }\n    return { result: result, changes: changes, data: data };\n});\n// Recalculate\nHooks('', 'beforeMap', function (stateObject, utils, data) {\n    var changes = [];\n    if (data[SymbolRecalc]) {\n        (function () {\n            var newVals = {};\n            var state = stateObject.next;\n            var recalcArray = data[SymbolRecalc];\n\n            var _loop = function _loop(i) {\n                var obj = recalcArray[recalcArray.length - i - 1];\n                if (obj) {\n                    objKeys(obj).forEach(function (key) {\n                        var _obj$key = obj[key],\n                            path = _obj$key.path,\n                            keyPath = _obj$key.keyPath,\n                            checkValue = _obj$key.checkValue;\n\n                        var keys = objKeys(getIn(state, path));\n                        var result = checkValue;\n                        for (var j = 0; j < keys.length; j++) {\n                            var pathString = path2string(path.concat(keys[j]), keyPath);\n                            var value = newVals.hasOwnProperty(pathString) ? newVals[pathString] : utils.get(state, pathString);\n                            if (value != checkValue) {\n                                result = !checkValue;\n                                break;\n                            }\n                        }\n                        changes.push([path, keyPath, result]);\n                        newVals[key] = result;\n                        // state = mergeState(state, makeSlice(push2array(path, SymbolData, keyPath, result))).state;\n                    });\n                }\n            };\n\n            for (var i = 0; i < recalcArray.length; i++) {\n                _loop(i);\n            }\n        })();\n    }\n    return changes;\n});\n// Array add/remove \nHooks('', 'beforeMap', function (stateObject, utils, data) {\n    var changes = [];\n    if (data[SymbolArray]) {\n        objKeys(data[SymbolArray]).forEach(function (key) {\n            var path = data[SymbolArray][key].path;\n\n            var state = stateObject.next;\n            var schema = state[SymbolData].schema;\n            var pathLength = path.concat(SymbolData, length);\n            var start = getIn(stateObject.prev, pathLength);\n            var end = getIn(stateObject.next, pathLength);\n            if (start < end) {\n                for (var i = start; i < end; i++) {\n                    var elemPath = path.concat(i);\n                    var dataObj = getIn(stateObject.next, elemPath);\n                    if (!dataObj) dataObj = {};\n                    var newElem = makeDataObject(schema, elemPath);\n                    dataObj = mergeState(dataObj, newElem.data).state;\n                    changes.push([elemPath, dataObj]);\n                    changes.push([[SymbolData, 'valueMap'], newElem.valueMap]);\n                }\n            }\n            if (start > end) {\n                for (var _i = end; _i < start; _i++) {\n                    changes.push([path.concat(_i), SymbolDelete]);\n                }\n            }\n        });\n    }\n    return changes;\n});\n/////////////////////////////////////////////\n//  Api class\n/////////////////////////////////////////////\n\nvar apiMixin = function () {\n    function apiMixin() {\n        _classCallCheck(this, apiMixin);\n\n        this.utils = utils;\n    }\n\n    _createClass(apiMixin, [{\n        key: \"initState\",\n        value: function initState(props, setStateFunc) {\n            var self = this;\n            if (!self.reducer) self.reducer = formReducer();\n            self.keyMap = makeKeyMapFromSchema(props.schema);\n            var formValues = props.formValues || {};\n\n            var _makeStateFromSchema = makeStateFromSchema(props.schema),\n                state = _makeStateFromSchema.state,\n                valueMap = _makeStateFromSchema.valueMap;\n\n            state[SymbolData]['valueMap'] = valueMap;\n            state[SymbolData]['name'] = props.name;\n            state = mergeState(state, [state, props.state || {}], {\n                symbol: true,\n                clear: true\n            }).state;\n            self.setNewState = setStateFunc;\n            self.setNewState(state);\n        }\n    }, {\n        key: \"_dispath\",\n        value: function _dispath(action) {\n            var self = this;\n            try {\n                self.isDispatching = true;\n                self.setNewState(self.reducer(self.currentState, action));\n            } finally {\n                self.isDispatching = false;\n            }\n            return action;\n        }\n    }]);\n\n    return apiMixin;\n}();\n\nvar makeApi = function (_apiMixin) {\n    _inherits(makeApi, _apiMixin);\n\n    function makeApi(props) {\n        _classCallCheck(this, makeApi);\n\n        var _this = _possibleConstructorReturn(this, (makeApi.__proto__ || Object.getPrototypeOf(makeApi)).call(this));\n\n        var self = _this;\n        self.initState(props, self.setState);\n        self.api = apiCreator(self._dispath, self.getState, self.keyMap, Hooks.get(props.name));\n        return _this;\n    }\n\n    _createClass(makeApi, [{\n        key: \"setState\",\n        value: function setState(state) {\n            this.currentState = state;\n        }\n    }, {\n        key: \"getState\",\n        value: function getState() {\n            return this.currentState;\n        }\n    }]);\n\n    return makeApi;\n}(apiMixin);\n\nexports.makeApi = makeApi;\n/////////////////////////////////////////////\n//  Main class\n/////////////////////////////////////////////\n\nvar Form = function (_react_1$PureComponen) {\n    _inherits(Form, _react_1$PureComponen);\n\n    /*  static propTypes = {\r\n     shchema: PropTypes.object.isRequired,\r\n     name: PropTypes.string,\r\n     store: PropTypes.object,\r\n     dispath: PropTypes.func,\r\n     values: PropTypes.object,\r\n     initalValues: PropTypes.object,\r\n     defaultValues: PropTypes.object,\r\n     };*/\n    function Form(props, context) {\n        _classCallCheck(this, Form);\n\n        var _this2 = _possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props, context));\n\n        var self = _this2;\n        var formValues = props.formValues,\n            state = props.state,\n            schema = props.schema,\n            name = props.name;\n\n        self.store = props.store;\n        self._setIface(props.iface);\n        self.schema = resolveSchema(schema);\n        self.initState({ formValues: formValues, state: state, schema: self.schema, name: name }, self.setState);\n        return _this2;\n    }\n\n    _createClass(Form, [{\n        key: \"shouldComponentUpdate\",\n        value: function shouldComponentUpdate(newProps) {\n            var self = this;\n            if (!isEqual(this.props, newProps, { skipKeys: ['state', 'store', 'iface'] })) {\n                if (this.props.store != newProps.store) this.store = newProps.store;\n                if (this.props.iface != newProps.iface || this.props.store != newProps.store) this._setIface(newProps.iface);\n                self.setState(newProps.state);\n                return false;\n            }\n            return true;\n        }\n    }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n            if (this.unsubscribe) this.unsubscribe();\n        }\n    }, {\n        key: \"_handleChange\",\n        value: function _handleChange() {\n            var self = this;\n            var nextState = self.store.getState()[formReducerValue][self.props.name];\n            if (nextState !== self.currentState) {\n                self.setState(nextState);\n            }\n        }\n    }, {\n        key: \"setState\",\n        value: function setState(state) {\n            if (this.currentState != state) {\n                var prevVersion = this.currentState[SymbolData].version;\n                this.currentState = state;\n                if (this.refs && this.refs['main']) this.refs['main']['_update'](state[SymbolData].version == prevVersion + 1);\n            }\n        }\n    }, {\n        key: \"_setIface\",\n        value: function _setIface(iface) {\n            var self = this;\n            if (!iface) iface = self.context.store || self.store ? 'redux' : 'local';\n            self.iface = iface;\n            if (self.iface == 'redux') {\n                var store = void 0;\n                if (self.store) store = self.store;else if (self.context.store) store = self.store = self.context.store;else throw new Error('In redux mode store must be provided either in context or in props.store');\n                self.dispath = store.dispath;\n                if (self.unsubscribe) self.unsubscribe();\n                self.unsubscribe = store.subscribe(self._handleChange);\n            } else {\n                if (self.unsubscribe) {\n                    self.unsubscribe();\n                    delete self.unsubscribe;\n                }\n                self.dispath = self._dispath;\n            }\n            self.api = apiCreator(self.dispath, function () {\n                return self.currentState;\n            }, self.keyMap, Hooks.get(self.props.name));\n        }\n    }, {\n        key: \"setFocus\",\n        value: function setFocus(path) {}\n    }, {\n        key: \"getState\",\n        value: function getState() {\n            return this.currentState;\n        }\n    }, {\n        key: \"render\",\n        value: function render() {\n            var self = this;\n            var _a = self.props,\n                name = _a.name,\n                formObjects = _a.formObjects,\n                formValues = _a.formValues,\n                schema = _a.schema,\n                iface = _a.iface,\n                Tag = _a.tag,\n                state = _a.state,\n                store = _a.store,\n                rest = __rest(_a, [\"name\", \"formObjects\", \"formValues\", \"schema\", \"iface\", \"tag\", \"state\", \"store\"]);\n            var form = {};\n            form.name = name;\n            form.formObjects = formObjects;\n            form.schema = self.schema;\n            form.api = self.api;\n            form.utils = self.utils;\n            if (!Tag) Tag = React.DOM.form;\n            // <Section ref=\"main\" path={[]} form={form}/>\n            // {...(formProps.shchema.id ? {id: formProps.shchema.id} : {})}\n            return React.createElement(Tag, __assign({}, rest, { name: name }), React.createElement(Field, { form: form, path: [] }), \";\");\n        }\n    }]);\n\n    return Form;\n}(react_1.PureComponent);\n\nForm.contextTypes = {\n    store: React.PropTypes.object\n};\nexports.Form = Form;\napplyMixins(Form, [apiMixin]);\n/////////////////////////////////////////////\n//  Section class\n/////////////////////////////////////////////\n\nvar Section = function (_react_1$Component) {\n    _inherits(Section, _react_1$Component);\n\n    function Section(props, context) {\n        _classCallCheck(this, Section);\n\n        var _this3 = _possibleConstructorReturn(this, (Section.__proto__ || Object.getPrototypeOf(Section)).call(this, props, context));\n\n        _this3.layouts = [];\n        _this3.ArrayItem = _this3._makeArrayItem();\n        _this3._build();\n        return _this3;\n    }\n\n    _createClass(Section, [{\n        key: \"_update\",\n        value: function _update() {}\n    }, {\n        key: \"_makeArrayItem\",\n        value: function _makeArrayItem() {\n            var formObjects = this.props.formObjects;\n\n            var Tag = React.DOM.div;\n            var _a = formObjects['Item'] || {},\n                _a$tag = _a.tag,\n                Item = _a$tag === undefined ? Tag : _a$tag,\n                itemRest = __rest(_a, [\"tag\"]);var _b = formObjects['ItemBody'] || {},\n                _b$tag = _b.tag,\n                ItemBody = _b$tag === undefined ? Tag : _b$tag,\n                itemBodyRest = __rest(_b, [\"tag\"]);var _c = formObjects['ItemMenu'] || {},\n                _c$tag = _c.tag,\n                ItemMenu = _c$tag === undefined ? Tag : _c$tag,\n                itemMenuRest = __rest(_c, [\"tag\"]);\n            return function (props) {\n                return React.createElement(Item, null, React.createElement(ItemBody, null, React.Children.only(props.childen)), React.createElement(ItemMenu, null));\n            };\n        }\n    }, {\n        key: \"_build\",\n        value: function _build() {\n            var self = this;\n            var _self$props = self.props,\n                path = _self$props.path,\n                form = _self$props.form;\n\n            var schemaPart = getSchemaPart(form.schema, path);\n            if (!schemaPart) return null;\n            var _schemaPart$x = schemaPart.x,\n                x = _schemaPart$x === undefined ? {} : _schemaPart$x,\n                _schemaPart$propertie = schemaPart.properties,\n                properties = _schemaPart$propertie === undefined ? {} : _schemaPart$propertie;\n            var _x$layoutsGroup = x.layoutsGroup,\n                layoutsGroup = _x$layoutsGroup === undefined ? [] : _x$layoutsGroup;\n\n            var keys = [];\n            var ArrayItem = false;\n            if (schemaPart.type == 'array') {\n                var _length = form.api.getSingle(path.concat(SymbolData, 'length')) || [];\n                for (var i = 0; i < _length; i++) {\n                    keys.push(i);\n                }ArrayItem = this.ArrayItem;\n            } else {\n                keys = objKeys(schemaPart.properties);\n            }\n            layoutsGroup.forEach(function (layout) {\n                var _layout$fields = layout.fields,\n                    fields = _layout$fields === undefined ? [] : _layout$fields;\n\n                if (!isArr(fields)) fields = fields.trim().replace(/\\s+/, ',').split(',');\n                fields.forEach(function (field) {\n                    self.layouts.push(ArrayItem ? React.createElement(ArrayItem, { rel: 'array_' + field }, React.createElement(Field, { form: form, path: path.concat(field) })) : React.createElement(Field, { form: form, path: path.concat(field) }));\n                    keys.splice(keys.indexOf(field), 1);\n                });\n            });\n            keys.forEach(function (field) {\n                self.layouts.push(ArrayItem ? React.createElement(ArrayItem, { rel: 'array_' + field }, React.createElement(Field, { form: form, path: path.concat(field) })) : React.createElement(Field, { form: form, path: path.concat(field) }));\n            });\n        }\n    }, {\n        key: \"render\",\n        value: function render() {\n            var _a = this.props,\n                _a$tag2 = _a.tag,\n                Tag = _a$tag2 === undefined ? React.DOM.div : _a$tag2,\n                form = _a.form,\n                path = _a.path,\n                rest = __rest(_a, [\"tag\", \"form\", \"path\"]);\n            return React.createElement(Tag, __assign({}, rest), this.layouts);\n        }\n    }]);\n\n    return Section;\n}(react_1.Component);\n/////////////////////////////////////////////\n//  Field class\n/////////////////////////////////////////////\n\n\nvar Field = function (_react_1$Component2) {\n    _inherits(Field, _react_1$Component2);\n\n    function Field() {\n        _classCallCheck(this, Field);\n\n        return _possibleConstructorReturn(this, (Field.__proto__ || Object.getPrototypeOf(Field)).apply(this, arguments));\n    }\n\n    _createClass(Field, [{\n        key: \"_build\",\n        value: function _build() {}\n    }, {\n        key: \"render\",\n        value: function render() {\n            function getProps(name) {\n                var result = mergeState(formObjects[name]['*'] || {}, [formObjects[name][type] || {}, x.custom && x.custom[name] || {}], { skipKeys: ['propsMapAdd'] });\n                var propsMapAdd = [];\n                push2array(propsMapAdd, result['propsMap'] || []);\n                push2array(propsMapAdd, formObjects[name]['*'] && formObjects[name]['*']['propsMapAdd'] || []);\n                push2array(propsMapAdd, formObjects[name][type] && formObjects[name][type]['propsMapAdd'] || []);\n                push2array(propsMapAdd, x.custom && x.custom[name] && x.custom[name]['propsMapAdd'] || []);\n                result['propsMap'] = propsMapAdd;\n                return result;\n                // return x.custom && x.custom[name] || formObjects[name][type] || formObjects[name]['*'] || {};\n            }\n            function mapProps(map, data) {\n                var result = {};\n                map.forEach(function (item) {\n                    if (!isArr(item)) item = [item, item];\n                    result[item[1]] = getIn(data, string2path(item[0]));\n                    var fn = item[2];\n                    if (fn) result[item[1]] = fn(api, result[item[1]]);\n                });\n                return result;\n            }\n            var _props = this.props,\n                form = _props.form,\n                path = _props.path;\n            var schema = form.schema,\n                formObjects = form.formObjects,\n                api = form.api,\n                utils = form.utils;\n\n            var schemaPart = getSchemaPart(schema, path);\n            var type = isArr(schemaPart.type) ? schemaPart.type[0] : schemaPart.type;\n            var x = schemaPart.x || {};\n            var _a = getProps('title'),\n                _a$tag3 = _a.tag,\n                TitleTag = _a$tag3 === undefined ? React.DOM.div : _a$tag3,\n                titlePropsMap = _a.propsMap,\n                titleProps = __rest(_a, [\"tag\", \"propsMap\"]);var _b = getProps('body'),\n                _b$tag2 = _b.tag,\n                BodyTag = _b$tag2 === undefined ? React.DOM.div : _b$tag2,\n                bodyPropsMap = _b.propsMap,\n                bodyProps = __rest(_b, [\"tag\", \"propsMap\"]);var _c = getProps('message'),\n                _c$tag2 = _c.tag,\n                MessageTag = _c$tag2 === undefined ? React.DOM.div : _c$tag2,\n                messagePropsMap = _c.propsMap,\n                messageProps = __rest(_c, [\"tag\", \"propsMap\"]);var _d = getProps('layout'),\n                layoutPropsMap = _d.propsMap,\n                layoutProps = __rest(_d, [\"propsMap\"]);\n            var MainTag = void 0;\n            var mainProps = void 0;\n            var mainPropsMap = [];\n            if (schemaPart.type == 'object' || schemaPart.type == 'array') {\n                MainTag = Section;\n                mainProps = getProps('main');\n                mainProps.form = form;\n                mainProps.path = path;\n            } else {\n                mainProps = getProps('main');\n                MainTag = mainProps.tag || React.DOM.div;\n                mainPropsMap = mainProps.propsMap;\n                mainProps = without(mainProps, false, ['tag', 'propsMap']);\n            }\n            var data = api.getSingle(path.concat(SymbolData));\n            var layoutData = mapProps(layoutPropsMap, data);\n            var mainData = mapProps(mainPropsMap, data);\n            var titleData = mapProps(titlePropsMap, data);\n            var bodyData = mapProps(bodyPropsMap, data);\n            var messageData = mapProps(messagePropsMap, data);\n            return React.createElement(Layout, __assign({ layout: layoutProps }, layoutData), React.createElement(TitleTag, __assign({}, titleProps, titleData), data.schemaData.title || ''), React.createElement(BodyTag, __assign({}, bodyProps, bodyData), React.createElement(MainTag, __assign({}, mainProps, mainData))), React.createElement(MessageTag, __assign({}, messageProps, messageData)));\n        }\n    }]);\n\n    return Field;\n}(react_1.Component);\n/////////////////////////////////////////////\n//  Basic components\n/////////////////////////////////////////////\n\n\nfunction Layout(_ref) {\n    var layout = _ref.layout,\n        children = _ref.children;\n\n    var _layout$style = layout.style,\n        style = _layout$style === undefined ? {} : _layout$style,\n        flexDirection = layout.flexDirection,\n        flex = layout.flex,\n        display = layout.display,\n        _layout$tag = layout.tag,\n        Tag = _layout$tag === undefined ? React.DOM.div : _layout$tag,\n        rest = __rest(layout, [\"style\", \"flexDirection\", \"flex\", \"display\", \"tag\"]);\n\n    style.display = display || style.display || 'flex';\n    style.flexDirection = flexDirection || style.flexDirection || 'column';\n    style.flex = flex || style.flex || '0 1 auto';\n    return React.createElement(Tag, __assign({ style: style }, rest), children);\n}\n/////////////////////////////////////////////\n//  Actions names\n/////////////////////////////////////////////\nvar actionsName = {};\nactionsName.setSingle = 'FFORM_SET_SINGLE';\nactionsName.setAsObject = 'FFORM_SET_AS_OBJECT';\n// actionsName.setAsSlice = 'FFORM_SET_AS_SLICE';\nactionsName.execBatch = 'FFORM_EXEC_BATCH';\n/////////////////////////////////////////////\n//  Actions function\n/////////////////////////////////////////////\nvar actions = {};\nactions.setSingle = function (path, value, keyMap, hooks) {\n    return { type: actionsName.setSingle, path: path, value: value, keyMap: keyMap, hooks: hooks };\n};\nactions.setAsObject = function (vals, keyPath, keyMap, hooks) {\n    return { type: actionsName.setAsObject, vals: vals, keyPath: keyPath, keyMap: keyMap, hooks: hooks };\n};\nactions.execBatch = function (batchedActions, hooks) {\n    return { type: actionsName.execBatch, batchedActions: batchedActions, hooks: hooks };\n};\n/////////////////////////////////////////////\n//  Reducer\n/////////////////////////////////////////////\nfunction formReducer(name) {\n    if (name) formReducerValue = name;\n    var reducersFunction = {};\n    // const utils: utilsApiType = {\n    //   get: (state: any, path: Path, keyPath: Path) => getIn(state, path.concat(SymbolData, keyPath)),\n    //   getIn,\n    //   isEqual\n    // };\n    function makeSliceFromUpdateItem(item) {\n        if (item.length == 3) return makeSlice(push2array(item[0], SymbolData, item[1], item[2]));else return makeSlice(push2array(item[0], item[1]));\n    }\n    function setChangesOnStateIfNeeded(state, resultObject, Hooks) {\n        var result = resultObject.result,\n            data = resultObject.data;\n\n        var mergeResult = mergeState(state, result);\n        ['afterMerge', 'beforeMap', 'applyMap', 'afterMap'].forEach(function (op) {\n            var fn = op == 'applyMap' ? applyMap : applyUpdateHooks;\n            var res = fn({\n                prev: state,\n                changes: mergeResult.changes,\n                next: mergeResult.state\n            }, data, Hooks[op]);\n            if (!res) return state; // all changes blocked\n            if (res.length) {\n                result = result.concat(res);\n                mergeResult = mergeState(state, result);\n            }\n        });\n        if (mergeResult.state != state) {\n            mergeResult.state[SymbolData]['version']++;\n            mergeResult.state[SymbolData]['changes'] = mergeResult.changes;\n        }\n        return mergeResult.state;\n    }\n    function applyMap(stateObject, additionalData) {\n        var result = [];\n        var valueMap = stateObject.next[SymbolData].valueMap;\n        var state = stateObject.next;\n        function recurse(changes) {\n            var track = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            var mapTo = getIn(valueMap, track.concat(SymbolMap));\n            if (mapTo) {\n                (function () {\n                    // value[path2string(to[0], to[1])] = {to, fn};\n                    var value = getIn(state, track);\n                    objKeys(mapTo).forEach(function (key) {\n                        var _mapTo$key = mapTo[key],\n                            to = _mapTo$key.to,\n                            fn = _mapTo$key.fn;\n\n                        if (fn) value = fn(state, utils, value);\n                        var updateItem = to[1] ? [to[0], to[1], value] : [to[0], value];\n                        result.push(updateItem);\n                    });\n                })();\n            }\n            objKeysAndSymbols(changes).forEach(function (key) {\n                return recurse(changes[key], track.concat(key));\n            });\n        }\n        recurse(stateObject.changes);\n        return result;\n    }\n    function applyUpdateHooks(stateObject, additionalData, hooks) {\n        var result = [];\n        for (var i = 0; i < hooks.length; i++) {\n            var res = hooks[i](stateObject, utils, additionalData);\n            if (!res) return false; // all changes blocked\n            res.forEach(function (item) {\n                return result.push(item);\n            });\n        }\n        return result;\n    }\n    function applyMergeHooks(item, state, data, hooks) {\n        var changes = [];\n        var result = true;\n        for (var i = 0; i < hooks.length; i++) {\n            var res = hooks[i](item, state, data, utils);\n            if (!res) return false;\n            if (res !== true) {\n                if (isArr(res)) res = { result: true, changes: res };\n                if (res.changes) res.changes.forEach(function (item) {\n                    return changes.push(item);\n                });\n                // if (res.data) data = mergeState(data, res.data).state;\n                result = res.result;\n            }\n        }\n        return { result: result, data: data, changes: changes };\n    }\n    function makePathValueSlicesForObject(state, action) {\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var vals = action.vals,\n            keyPath = action.keyPath,\n            keyMap = action.keyMap;\n\n        var items = object2PathValues(vals); // get array of pathValues where item.pop() - value\n        // let data = {};\n        var changes = [];\n        var result = [];\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i]; // item.pop() - value\n            var value = item.pop();\n            item = keyMap.key2path(item); // resolve key to path\n            if (getIn(state, item.concat(SymbolData, keyPath)) != value) {\n                var res = applyMergeHooks([item, keyPath, value], state, data, action.hooks.beforeMerge);\n                if (res) {\n                    if (res.result) result.push([item, keyPath, value]);\n                    if (res.changes) res.changes.forEach(function (item) {\n                        return changes.push(item);\n                    }); // additional changes\n                }\n            }\n        }\n        changes.forEach(function (item) {\n            return result.push(item);\n        }); // add changes to the end\n        return { result: result.map(function (item) {\n                return makeSliceFromUpdateItem(item);\n            }), data: data };\n    }\n    function makePathValueSlicesForSingle(state, action) {\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var value = action.value,\n            path = action.path,\n            keyMap = action.keyMap;\n\n        var items = object2PathValues(value); // get array of items, where item.pop() - value\n        var pathMapped = keyMap.key2path(path);\n        var result = [];\n        // let data = {};\n        var changes = [];\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            var _value = item.pop();\n            if (getIn(state, pathMapped.concat(SymbolData, item)) != _value) {\n                var res = applyMergeHooks([pathMapped, item, _value], state, data, action.hooks.beforeMerge);\n                if (res) {\n                    if (res.result) result.push([pathMapped, item, _value]);\n                    if (res.changes) res.changes.forEach(function (item) {\n                        return changes.push(item);\n                    }); // additional changes\n                }\n            }\n        }\n        changes.forEach(function (item) {\n            return result.push(item);\n        }); // add changes to the end\n        return { result: result.map(function (item) {\n                return makeSliceFromUpdateItem(item);\n            }), data: data };\n    }\n    reducersFunction[actionsName.setSingle] = function (state, action) {\n        var path = action.path.concat(SymbolData);\n        var pathValueSlices = makePathValueSlicesForSingle(state, action);\n        return setChangesOnStateIfNeeded(state, pathValueSlices, action.hooks);\n    };\n    reducersFunction[actionsName.setAsObject] = function (state, action) {\n        //let pathValueSlices: any[] = makePathValueSlicesForObject(action.vals, action.keyPath, action.keyMap);\n        var pathValueSlices = makePathValueSlicesForObject(state, action);\n        return setChangesOnStateIfNeeded(state, pathValueSlices, action.hooks);\n    };\n    reducersFunction[actionsName.execBatch] = function (state, action) {\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        var result = [];\n        // let data = {};\n        action.batchedActions.forEach(function (action) {\n            var fn = void 0;\n            if (action.type == actionsName.setSingle) fn = makePathValueSlicesForSingle;else if (action.type == actionsName.setAsObject) fn = makePathValueSlicesForObject;\n            var res = fn(state, action, data);\n            res.result.forEach(function (item) {\n                return result.push(item);\n            });\n            // data = mergeState(data, res.data).state\n        });\n        return setChangesOnStateIfNeeded(state, { result: result, data: data }, action.hooks); // setChangesOnStateIfNeeded(mergeState(state, pathValueSlices), state);\n    };\n    return function (state, action) {\n        var reduce = reducersFunction[action.type];\n        return reduce ? reduce(state, action) : state;\n    };\n}\nexports.formReducer = formReducer;\n/////////////////////////////////////////////\n//  API\n/////////////////////////////////////////////\nfunction apiCreator(dispath, getState, keyMap, hooks) {\n    function getAsSlices(store, keyPath, keyMap) {\n        var track = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n        var type = store[SymbolData].schemaData.type;\n        if (type == 'array') {\n            var _ret4 = function () {\n                var arr = [];\n                objKeys(store).forEach(function (key) {\n                    var childType = store[key][SymbolData].schemaData.type;\n                    if (childType == 'object' || childType == 'array') arr[key] = mergeState({}, getAsSlices(store[key], keyPath, keyMap)).state;else arr[key] = getIn(store[key][SymbolData], keyPath);\n                });\n                return {\n                    v: makeSlice(push2array(keyMap.path2key(track), arr))\n                };\n            }();\n\n            if ((typeof _ret4 === \"undefined\" ? \"undefined\" : _typeof2(_ret4)) === \"object\") return _ret4.v;\n        } else if (type == 'object') {\n            var _ret5 = function () {\n                var result = []; // (store[SymbolData].schemaData.type == 'array') ? [] : {};\n                objKeys(store).forEach(function (key) {\n                    return result.push(getAsSlices(store[key], keyPath, keyMap, track.concat(key)));\n                });\n                return {\n                    v: result\n                };\n            }();\n\n            if ((typeof _ret5 === \"undefined\" ? \"undefined\" : _typeof2(_ret5)) === \"object\") return _ret5.v;\n        } else {\n            return makeSlice(push2array(keyMap.path2key(track), getIn(store[SymbolData], keyPath)));\n        }\n    }\n    var api = {};\n    var batching = false;\n    var batchedActions = [];\n    var dispathAction = dispath;\n    api.getState = getState;\n    api.getSingle = function (path) {\n        return getIn(getState(), typeof path == 'string' ? string2path(path) : path);\n    };\n    api.setSingle = function (path, value) {\n        return dispathAction(actions.setSingle(typeof path == 'string' ? string2path(path) : path, value, keyMap, hooks));\n    };\n    api.getAsObject = function (keyPath) {\n        return mergeState({}, getAsSlices(getState(), keyPath, keyMap)).state;\n    };\n    api.setAsObject = function (vals, keyPath) {\n        return dispathAction(actions.setAsObject(vals, keyPath, keyMap, hooks));\n    };\n    api.getValues = function () {\n        return api.getAsObject(['values', 'current']);\n    };\n    api.setValues = function (vals) {\n        return api.setAsObject(vals, ['values', 'current']);\n    };\n    api.getPristine = function () {\n        return api.getAsObject(['values', 'pristine']);\n    };\n    api.setPristine = function (vals) {\n        return api.setAsObject(vals, ['values', 'pristine']);\n    };\n    api.getDefault = function () {\n        return api.getAsObject(['values', 'default']);\n    };\n    api.setDefault = function (vals) {\n        return api.setAsObject(vals, ['values', 'default']);\n    };\n    api.arrayAddItem = function (path) {};\n    api.arrayDelItem = function (path, index) {};\n    api.arrayMoveItem = function (path, from, to) {};\n    api.show = function (path) {};\n    api.hide = function (path) {};\n    api.showOnly = function (path) {};\n    api.startBatch = function () {\n        batching = true;\n        dispathAction = batchedActions.push;\n    };\n    api.execBatch = function () {\n        batching = false;\n        dispathAction = dispath;\n        dispath(actions.execBatch(batchedActions, hooks));\n        batchedActions = [];\n    };\n    return api;\n}\n/////////////////////////////////////////////\n//      Schema utilities\n/////////////////////////////////////////////\n// function getSchemaApi(schema: JsonSchema) {\n//   return {schema, getSchemaPart: getSchemaPart.bind(null, schema), makeDataObject: makeDataObject.bind(null, schema)};\n// };\nfunction getSchemaPart(resolvedSchema, path) {\n    function getArrayItemSchemaPart(index, schemaPart) {\n        var items = [];\n        if (schemaPart.items) {\n            if (!isArr(schemaPart.items)) return schemaPart.items;else items = schemaPart.items;\n        }\n        if (index < items.length) return items[index];else {\n            if (schemaPart.additionalItems) {\n                if (schemaPart.additionalItems !== true) return schemaPart.additionalItems;\n                return items[items.length - 1];\n            }\n        }\n        throw new Error(errorText + path.join('.'));\n    }\n    var errorText = 'Schema path not found: ';\n    var schemaPart = resolvedSchema;\n    for (var i = 0; i < path.length; i++) {\n        if (!schemaPart) throw new Error(errorText + path.join('.'));\n        if (schemaPart.type == 'array') {\n            schemaPart = getArrayItemSchemaPart(path[i], schemaPart);\n        } else {\n            if (schemaPart.properties && schemaPart.properties[path[i]]) schemaPart = schemaPart.properties[path[i]];else throw new Error(errorText + path.join('.'));\n            ;\n        }\n    }\n    return schemaPart;\n}\nfunction makeDataObject(resolvedSchema, path) {\n    function getValueFromParents(path, keyPath, resolvedSchema) {\n        var tmpPath = path.concat(null);\n        for (var i = 0; i < path.length + 1; i++) {\n            tmpPath.pop();\n            var _schemaPart = getSchemaPart(resolvedSchema, path);\n            if (_schemaPart) return getIn(_schemaPart, keyPath);\n        }\n    }\n    function getParentArrayValue(path, resolvedSchema) {\n        var pathPart = path.slice();\n        var keyPart = [];\n        var result = void 0;\n        for (var i = 0; i < path.length; i++) {\n            var key = pathPart.pop();\n            key.unshift(key);\n            var _schemaPart2 = getSchemaPart(resolvedSchema, pathPart);\n            if (!_schemaPart2) return;\n            if (_schemaPart2.type == 'array') {\n                var tmp = getIn(_schemaPart2.default, keyPart);\n                if (tmp) result = tmp;\n            }\n        }\n        return result;\n    }\n    function mergeValueMapArray2Object(valueMapArray) {\n        return mergeState({}, valueMapArray.map(function (item) {\n            var from = item[0];\n            var to = item[1];\n            var fn = item[2];\n            var pathValue = from[0].slice();\n            if (from[1]) push2array(pathValue, SymbolData, from[1]);\n            var value = {};\n            value[path2string(to[0], to[1])] = { to: to, fn: fn };\n            return makeSlice(push2array(pathValue, SymbolMap, value));\n        }));\n    }\n    var schemaPart = getSchemaPart(resolvedSchema, path);\n    if (!schemaPart) throw new Error(\"Schema not found in path \\\"\" + path.join('.') + \"\\\"\");\n    // let x = schemaPart.x || {};\n    var result = {};\n    result.path = path;\n    if (path.length) result.name = path[path.length - 1];else result.version = 0; // this is root object\n    result.schema = resolvedSchema;\n    result.schemaPart = schemaPart;\n    result.schemaData = {\n        id: schemaPart.id,\n        title: schemaPart.title,\n        description: schemaPart.description,\n        type: schemaPart.type\n    };\n    result.status = {\n        touched: false,\n        reTouched: false,\n        pristine: true\n    };\n    result.messages = {};\n    result.funcs = {\n        parse: null,\n        format: null,\n        validators: null\n    };\n    result.params = {};\n    result.params.live = getValueFromParents(path, ['x', 'live'], resolvedSchema);\n    result.params.readonly = getValueFromParents(path, ['x', 'readonly'], resolvedSchema);\n    result.params.disabled = getValueFromParents(path, ['x', 'disabled'], resolvedSchema);\n    result.params.required = schemaPart.required;\n    if (schemaPart.type != 'object' && schemaPart.type != 'array') {\n        result.params.placeholder = schemaPart.x && schemaPart.x.placeholder;\n        result.params.autofocus = schemaPart.x && schemaPart.x.autofocus;\n        result.values = {\n            // current: getParentArrayValue(path, resolvedSchema) || schemaPart.default,\n            // inital: getParentArrayValue(path, resolvedSchema) || schemaPart.default,\n            'default': getParentArrayValue(path, resolvedSchema) || schemaPart.default\n        };\n    }\n    var valueMapArray = [];\n    // let schemaApi = getSchemaApi(resolvedSchema);\n    if (schemaPart.x && schemaPart.x.dataMap) {\n        schemaPart.x.dataMap.forEach(function (item) {\n            var from = item[0];\n            from = string2path(typeof from == 'function' ? from(resolvedSchema, utils, path) : from, path);\n            var to = item[1];\n            to = string2path(typeof to == 'function' ? to(resolvedSchema, utils, path) : to, path);\n            valueMapArray.push([from, to, item[2]]);\n        });\n    }\n    return { data: result, valueMap: mergeValueMapArray2Object(valueMapArray) };\n}\nfunction makeStateFromSchema(resolvedSchema) {\n    var currentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    var result = {};\n    var valueMapObjects = [];\n    var dataObj = makeDataObject(resolvedSchema, currentPath);\n    result[SymbolData] = dataObj.data;\n    valueMapObjects.push(dataObj.valueMap);\n    if (resolvedSchema.type == 'array') {\n        var vals = resolvedSchema.default;\n        var idx = 0;\n        if (vals && isArr(vals)) idx = vals.length;\n        if (resolvedSchema.minItems) idx = Math.max(idx, resolvedSchema.minItems);\n        for (var i = 0; i < idx; i++) {\n            var _dataObj = makeStateFromSchema(resolvedSchema, currentPath.concat(i));\n            valueMapObjects.push(_dataObj.valueMap);\n            result[i] = _dataObj.state;\n        }\n        result[SymbolData].length = idx;\n    } else {\n        objKeys(resolvedSchema.properties).forEach(function (field) {\n            if (resolvedSchema.properties) {\n                if (resolvedSchema.properties[field].type == 'object' || resolvedSchema.properties[field].type == 'array') {\n                    var _dataObj2 = makeStateFromSchema(resolvedSchema, currentPath.concat(field));\n                    valueMapObjects.push(_dataObj2.valueMap);\n                    result[field] = _dataObj2.state;\n                } else {\n                    result[field] = {};\n                    var _dataObj3 = makeDataObject(resolvedSchema.properties[field], currentPath.concat(field));\n                    valueMapObjects.push(_dataObj3.valueMap);\n                    result[field][SymbolData] = _dataObj3.data;\n                }\n            }\n        });\n    }\n    return { state: result, valueMap: mergeState({}, valueMapObjects) };\n}\nfunction makeKeyMapFromSchema(resolvedSchema) {\n    var path2start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    function mapPath2key(prefix, obj) {\n        var result = {};\n        objKeys(obj).forEach(function (val) {\n            if (typeof obj[val] == 'string') result[val] = prefix + obj[val];else result[val] = mapPath2key(prefix, obj[val]);\n        });\n        return result;\n    }\n    function recurse(resolvedSchema) {\n        var currentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n        var schemaPart = getSchemaPart(resolvedSchema, currentPath);\n        if (!schemaPart) return null;\n        var key2path = {},\n            path2key = {},\n            dataObj = {},\n            pKey = currentPath[currentPath.length - 1];\n        dataObj[SymbolData] = {};\n        if (schemaPart.type == \"object\") {\n            if (schemaPart.properties) {\n                objKeys(schemaPart.properties).forEach(function (key) {\n                    if (schemaPart && schemaPart.properties) {\n                        var _obj = schemaPart.properties[key];\n                        var objMap = void 0;\n                        if (_obj.type == 'object' || _obj.type == 'array') {\n                            (function () {\n                                objMap = recurse(resolvedSchema, currentPath.concat(key));\n                                var objMapData = objMap[SymbolData];\n                                if (objMapData.key2path && objKeys(objMapData.key2path).length) {\n                                    dataObj[key] = objMap;\n                                    if (_obj.x && _obj.x.flatten) {\n                                        (function () {\n                                            var prefix = _obj.x.flatten !== true && _obj.x.flatten || '';\n                                            objKeys(objMapData.key2path).forEach(function (key2) {\n                                                if (key2path.hasOwnProperty(prefix + key2)) throw new Error(\"Duplicate flatten name for \" + (prefix + key2));\n                                                key2path[prefix + key2] = [key].concat(objMapData.key2path[key2]);\n                                            });\n                                            path2key[key] = mapPath2key(prefix, objMapData.path2key);\n                                        })();\n                                    }\n                                }\n                            })();\n                        } else {\n                            key2path[key] = key;\n                            path2key[key] = key;\n                        }\n                    }\n                });\n            }\n        } else if (schemaPart.type == \"array\") {\n            var items = [];\n            var addable = false;\n            if (schemaPart.items) items = schemaPart.items;\n            if (!isArr(items)) items = [items];\n            if (schemaPart.additionalItems) {\n                addable = true;\n                if (schemaPart.additionalItems !== true) items.push(schemaPart.additionalItems);\n            } else addable = false;\n            for (var key = 0; key < items.length; key++) {\n                var _obj2 = items[key];\n                if (_obj2.type == 'object' || _obj2.type == 'array') dataObj[key] = recurse(resolvedSchema, currentPath.concat(key));\n            }\n            dataObj[SymbolData].isArray = true;\n            dataObj[SymbolData].addable = addable;\n            dataObj[SymbolData].length = items.length;\n        }\n        dataObj[SymbolData].key2path = key2path;\n        dataObj[SymbolData].path2key = path2key;\n        return dataObj;\n    }\n    function getMapData(obj, path) {\n        var result = obj;\n        for (var i = 0; i < path.length; i++) {\n            var key = path[i];\n            if (result[SymbolData].isArray) {\n                if (parseInt(key) < result[SymbolData].length) {\n                    result = result[key];\n                } else {\n                    if (result[SymbolData].addable) result = result[result[SymbolData].length - 1];else result = undefined;\n                }\n            } else result = result[key];\n            if (!result) return result;\n        }\n        return result;\n    }\n    var dataObj = recurse(resolvedSchema, path2start);\n    return {\n        key2path: function key2path(keyPath) {\n            if (typeof keyPath == 'string') keyPath = string2path(keyPath);\n            var result = [];\n            keyPath.forEach(function (key) {\n                var obj = getMapData(dataObj, result);\n                if (obj[SymbolData].key2path[key]) {\n                    result = result.concat(obj[SymbolData].key2path[key]);\n                } else result.push(key);\n            });\n            return result;\n        },\n        path2key: function path2key(path) {\n            var result = [];\n            var i = 0;\n            while (i < path.length) {\n                var key = path[i];\n                var _obj3 = getMapData(dataObj, path.slice(0, i));\n                var path2key = _obj3[SymbolData].path2key;\n                if (path2key) {\n                    var j = 0;\n                    while (1) {\n                        if (path2key[key]) {\n                            if (typeof path2key[key] == 'string') {\n                                key = path2key[key];\n                                i += j;\n                                break;\n                            } else {\n                                path2key = path2key[key];\n                                j++;\n                                key = path[i + j];\n                            }\n                        } else {\n                            key = path[i];\n                            break;\n                        }\n                    }\n                }\n                result.push(key);\n                i++;\n            }\n            return result;\n        }\n    };\n}\nexports.makeKeyMapFromSchema = makeKeyMapFromSchema;\n/////////////////////////////////////////////\n//      Utilities\n/////////////////////////////////////////////\nvar utils = {};\nutils.get = function (state, path) {\n    return getIn(state, string2path(path));\n};\nutils.isEqual = isEqual;\nutils.mergeState = mergeState;\nutils.string2path = string2path;\nutils.getSchemaPart = getSchemaPart;\nutils.makeDataObject = makeDataObject;\nfunction path2string(path, keyPath) {\n    return (keyPath ? path.concat('@', keyPath) : path).join('.');\n}\nfunction string2path(str, path) {\n    var res = str.split('.@.');\n    res[0] = res[0].split('.');\n    if (res[1]) res[1] = res[1].split('.');\n    if (path) res[0] = path.concat(res[0]);\n    return res;\n}\nfunction push2array(array) {\n    for (var _len = arguments.length, vals = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        vals[_key - 1] = arguments[_key];\n    }\n\n    array.push.apply(array, vals);\n    return array;\n}\nfunction object2PathValues(vals) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var track = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var fn = options.symbol ? objKeysAndSymbols : objKeys;\n    var check = options.arrayAsObject ? isMergeableObject : isObject;\n    var result = [];\n    fn(vals).forEach(function (key) {\n        var path = track.concat(key);\n        if (check(vals[key])) object2PathValues(vals[key], options, path).forEach(function (item) {\n            return result.push(item);\n        }); // result = result.concat(object2PathValues(vals[key], path));\n        else result.push(push2array(path, vals[key]));\n    });\n    if (!result.length) return [push2array(track.slice(), {})]; // empty object\n    return result;\n}\nexports.object2PathValues = object2PathValues;\nfunction moveArrayElems(arr, from, to) {\n    var length = arr.length;\n    from = (from % length + length) % length;\n    to = (to % length + length) % length;\n    var elem = arr[from];\n    if (from < to) for (var i = from; i < to; i++) {\n        arr[i] = arr[i + 1];\n    } else for (var _i2 = from; _i2 > to; _i2--) {\n        arr[_i2] = arr[_i2 - 1];\n    }arr[to] = elem;\n    return arr;\n}\nfunction resolveSchema(schema) {\n    var reference = schema['$ref'];\n    if (reference) {\n        if (!reference.match(/^#(\\/([a-zA-Z_][a-zA-Z_0-9]*|[0-9]+))*$/)) {\n            throw new Error('reference ' + reference + ' has unsupported format');\n        }\n        return mergeState(getIn(schema, reference.split('/').slice(1)), without(schema, false, '$ref')).state;\n    } else {\n        return schema;\n    }\n}\n;\nfunction makeSlice(pathValue) {\n    var track = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (pathValue.length == 0) return {};\n    if (pathValue.length == 1) return pathValue[0];\n    var keys = pathValue[0];\n    if (typeof keys === 'function') keys = keys(pathValue, track);\n    if (!isArr(keys)) keys = [keys];\n    var result = {};\n    keys.forEach(function (key) {\n        result[key] = makeSlice(pathValue.slice(1), track.concat(key));\n    });\n    return result;\n}\nexports.makeSlice = makeSlice;\nfunction getIn(store, path) {\n    if (path.length == 0 || store == undefined) return store;else if (typeof path[0] === 'function') return getIn(store[path[0](store)], path.slice(1));\n    return getIn(store[path[0]], path.slice(1));\n}\nexports.getIn = getIn;\n;\nfunction getSlice(store, path) {\n    var track = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    return makeSlice(path.concat(getIn(store, path)));\n}\nfunction without(obj) {\n    for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        rest[_key2 - 2] = arguments[_key2];\n    }\n\n    var symbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    //const args = arrFrom(rest); // [].slice.call(arguments);\n    var result = isArr(obj) ? [] : {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).forEach(function (key) {\n        if (!~rest.indexOf(key)) result[key] = obj[key];\n    });\n    return result;\n}\n;\nfunction split(test, obj) {\n    var symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var passed = {};\n    var wrong = {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).forEach(function (key) {\n        var val = obj[key];\n        if (test(key, val)) passed[key] = val;else wrong[key] = val;\n    });\n    return [passed, wrong];\n}\n;\nfunction map(fnc, obj) {\n    var symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var result = {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).forEach(function (key) {\n        return result[key] = fnc(obj[key]);\n    });\n    return result;\n}\n;\nfunction mapKeys(fnc, obj) {\n    var symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var result = {};\n    var fn = symbol ? objKeys : objKeysAndSymbols;\n    fn(obj).map(function (key) {\n        return result[fnc(key)] = obj[key];\n    });\n    return result;\n}\n;\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\nfunction is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n        // Steps 6.b-6.e: +0 != -0\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        // Step 6.a: NaN == NaN\n        return x !== x && y !== y;\n    }\n}\nfunction isEqual(objA, objB) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (is(objA, objB)) return true;\n    if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) return false;\n    var fn = options.symbol ? objKeysAndSymbols : objKeys;\n    var keysA = fn(objA);\n    var keysB = fn(objB);\n    if (keysA.length !== keysB.length) return false;\n    var _options$skipKeys = options.skipKeys,\n        skipKeys = _options$skipKeys === undefined ? [] : _options$skipKeys,\n        _options$deepKeys = options.deepKeys,\n        deepKeys = _options$deepKeys === undefined ? [] : _options$deepKeys;\n\n    for (var i = 0; i < keysA.length; i++) {\n        if (~skipKeys.indexOf(keysA[i])) continue; // if key is an skip key, skip comparison\n        if (options.deep || ~deepKeys.indexOf(keysA[i])) {\n            var result = isEqual(objA[keysA[i]], objB[keysA[i]], options);\n            if (!result) return false;\n        } else if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isEqual = isEqual;\n// returns {state, changes} where state is new object only if changes were made, otherwise return {state} where state is passed state\nfunction mergeState(state, obj) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var result = {};\n    var changes = {};\n    var fn = options.symbol ? objKeysAndSymbols : objKeys;\n    if (!isObject(state)) state = {}; // return only objects\n    if (isArr(obj)) {\n        if (obj.length == 0) return { state: state }; // no changes should be done\n        else if (obj.length == 1) obj = obj[0];else obj = obj.reduce(function (prev, next) {\n                return mergeState(prev, next, { symbol: options.symbol }).state;\n            }); // merge without clear\n    }\n    if (!isObject(obj)) return { state: state }; // merge only objects, may be make here throw\n    var _options$skipKeys2 = options.skipKeys,\n        skipKeys = _options$skipKeys2 === undefined ? [] : _options$skipKeys2;\n\n    fn(state).forEach(function (key) {\n        if (!~skipKeys.indexOf(key)) result[key] = state[key];\n    });\n    fn(obj).forEach(function (key) {\n        if (!~skipKeys.indexOf(key)) {\n            if (!isObject(obj[key])) {\n                if (options.clear && obj[key] === SymbolDelete) {\n                    if (state.hasOwnProperty(key)) changes[key] = obj[key];\n                    if (result.hasOwnProperty(key)) delete result[key];\n                } else {\n                    if (!is(state[key], obj[key]) || !state.hasOwnProperty(key)) changes[key] = obj[key];\n                    result[key] = obj[key];\n                }\n            } else {\n                var tmp = mergeState(state[key], obj[key], options);\n                if (options.clear && fn(tmp.state).length == 0) {\n                    if (state.hasOwnProperty(key)) changes[key] = SymbolDelete;\n                    if (result.hasOwnProperty(key)) delete result[key];\n                } else {\n                    if (tmp.changes) changes[key] = tmp.changes;\n                    result[key] = tmp.state;\n                }\n            }\n        }\n    });\n    if (fn(changes).length == 0) return { state: state };else return { state: result, changes: changes };\n}\nexports.mergeState = mergeState;\nfunction isObject(val) {\n    return isMergeableObject(val) && !isArr(val);\n}\nfunction isMergeableObject(val) {\n    var nonNullObject = val && (typeof val === \"undefined\" ? \"undefined\" : _typeof2(val)) === 'object';\n    return nonNullObject && Object.prototype.toString.call(val) !== '[object RegExp]' && Object.prototype.toString.call(val) !== '[object Date]';\n}\n// export function makeSlice(path: PathSlice, value: any, track: PathSlice = []): StateType {\n//   if (path.length == 0) return value;\n//   let keys: any = path[0];\n//   if (typeof keys === 'function') keys = keys(path, track);\n//   if (!isArr(keys)) keys = [keys];\n//   let result = {};\n//   keys.forEach((key: string | number) => {\n//     let newTrack = track.slice();\n//     newTrack.push(key);\n//     result[key] = makeSlice(path.slice(1), value, newTrack)\n//   });\n//   return result;\n// }\n// export function getSlice(store: any, path: PathSlice, track: PathSlice = []): {} {\n//   if (path.length == 0 || store == undefined)\n//     return store;\n//   else {\n//     let keys: any = path[0];\n//     if (typeof keys === 'function') keys = keys(store, path, track);\n//     if (!isArr(keys)) keys = [keys];\n//     let result = {};\n//     keys.forEach((key: string | number) => {\n//       let newTrack = track.slice();\n//       newTrack.push(key);\n//       result[key] = getSlice(store[key], path.slice(1), newTrack)\n//     });\n//     return result;\n//   }\n// };\n//\n// export function setIn(store: {}, path: Path, value: any) {\n//   if (path.length == 0)\n//     return value;\n//   else {\n//     let child = (store == null) ? null : store[path[0]];\n//     value = setIn(child || [], path.slice(1), value);\n//     return mergeState(store, object(path[0], value)).state;\n//   }\n// };\n//\n//\n// export function setSlice(store: any, ...rest: any[]): SetSliceResultType {\n//   let changes = [];\n//   for (let i = 0; i + 1 < rest.length; i += 2) {\n//     let path = rest[i], value = rest[i + 1];\n//     if (!isEqual(getIn(store, path), value, {deep: true, symbol: true, onlyKeysB: true}))\n//       changes.push(makeSlice(value, path));\n//   }\n//   if (changes.length == 0) return {data: store};\n//   if (changes.length > 1) changes = merge.all(changes); else changes = changes[0];\n//   return {data: merge(store, changes), changes}\n// }\n//\n// function object(...args: any[]) {\n//   // const args = arrFrom(arguments);\n//   let result: any = [];\n//   for (let i = 0; i + 1 < args.length; i += 2) {\n//     let x = args[i];\n//     if (typeof x != 'number' || x < 0 || x % 1 != 0) result = {};\n//   }\n//   for (let i = 0; i + 1 < args.length; i += 2) result[args[i]] = args[i + 1];\n//   return result;\n// };\n// function flatten(data: any, symbol = false) {\n//   const result = {};\n//   const delimiter = '.';\n//   const fn = symbol ? objKeys : objKeysAndSymbols;\n//\n//   function recurse(cur: any, prop = '') {\n//     if (Object(cur) !== cur) {\n//       result[prop] = cur;\n//     } else if (isArr(cur)) {\n//       if (!cur.length) result[prop] = [];\n//\n//       cur.forEach((item, i) => {\n//         recurse(cur[i], prop\n//           ? [prop, i].join(delimiter)\n//           : `${i}`);\n//       });\n//     } else {\n//       let isEmpty = true;\n//\n//       fn(cur).forEach((key) => {\n//         isEmpty = false;\n//         recurse(cur[key], prop\n//           ? [prop, key].join(delimiter)\n//           : key);\n//       });\n//\n//       if (isEmpty) result[prop] = {};\n//     }\n//   }\n//   recurse(data);\n//   return result;\n// }\n//\n// function clear(state: any, symbol = false) { // remove undefined values and empty objects or arrays\n//   let result: any, isArray: boolean;\n//   if (state === undefined) result = undefined;\n//   else if (isArr(state) || isObject(state)) {\n//     isArray = isArr(state);\n//     result = isArray ? [] : {};\n//     const fn = symbol ? objKeys : objKeysAndSymbols;\n//     fn(state).forEach(key => {\n//       let val = clear(state[key]);\n//       if (val !== undefined) {\n//         if (isArray) result.push(val); else result[key] = val;\n//       }\n//     });\n//     if (fn(result).length == 0) result = undefined;\n//   } else result = state;\n//   return result;\n// };\n//\n// function getDiffForSecondObject(objA: any, objB: any, symbol = false) {\n//   const fn = symbol ? objKeysAndSymbols : objKeys;\n//   const result = {};\n//   fn(objB).forEach((key) => {\n//     if (isObject(objB)) {\n//       if (isObject(objA)) result[key] = getDiffForSecondObject(objA[key], objB[key], symbol);\n//       else result[key] = objB[key];\n//     } else {\n//       if (objB[key] != objA[key]) result[key] = objB[key];\n//     }\n//   });\n//   return result;\n// }\n/*\r\n /////////////////////////////////////////////\r\n // https://github.com/KyleAMathews/deepmerge, modified to merge Symbols\r\n /////////////////////////////////////////////\r\n\r\n\r\n const merge: any = function () {\r\n\r\n function emptyTarget(val: any) {\r\n return isArr(val) ? [] : {}\r\n }\r\n\r\n function cloneIfNecessary(value: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const clone = optionsArgument && optionsArgument.clone === true;\r\n return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value\r\n }\r\n\r\n function defaultArrayMerge(target: any, source: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const destination = target.slice();\r\n source.forEach(function (e: any, i: any) {\r\n if (typeof destination[i] === 'undefined') {\r\n destination[i] = cloneIfNecessary(e, optionsArgument)\r\n } else if (isMergeableObject(e)) {\r\n destination[i] = deepmerge(target[i], e, optionsArgument)\r\n } else if (target.indexOf(e) === -1) {\r\n destination.push(cloneIfNecessary(e, optionsArgument))\r\n }\r\n });\r\n return destination\r\n }\r\n\r\n function mergeObject(target: any, source: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const destination = {};\r\n let fn = (optionsArgument && optionsArgument.symbol) ? objKeysAndSymbols : objKeys;\r\n if (isMergeableObject(target)) {\r\n fn(target).forEach(function (key) {\r\n destination[key] = cloneIfNecessary(target[key], optionsArgument)\r\n })\r\n }\r\n fn(source).forEach(function (key) {\r\n if (!isMergeableObject(source[key]) || !target[key]) {\r\n destination[key] = cloneIfNecessary(source[key], optionsArgument)\r\n } else {\r\n destination[key] = deepmerge(target[key], source[key], optionsArgument)\r\n }\r\n });\r\n return destination\r\n }\r\n\r\n const deepmerge: any = function (target: any, source: any, optionsArgument?: DeepmergeOptionsArgument) {\r\n const array = isArr(source);\r\n const options = optionsArgument || {arrayMerge: defaultArrayMerge};\r\n const arrayMerge = options.arrayMerge || defaultArrayMerge;\r\n\r\n if (array) {\r\n return isArr(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)\r\n } else {\r\n return mergeObject(target, source, optionsArgument)\r\n }\r\n };\r\n\r\n deepmerge.all = function deepmergeAll(array: any[], optionsArgument?: DeepmergeOptionsArgument) {\r\n if (array.length < 2) throw new Error('Should be at least two elements');\r\n\r\n // we are sure there are at least 2 values, so it is safe to have no initial value\r\n return array.reduce(function (prev, next) {\r\n return deepmerge(prev, next, optionsArgument)\r\n })\r\n };\r\n\r\n return deepmerge\r\n\r\n }();*/"
    }
  ],
  "filteredModules": 0,
  "children": []
}
